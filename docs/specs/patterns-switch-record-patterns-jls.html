<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc,fixuphtml" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Pattern Matching for switch (Fourth Preview) and Record Patterns (Second Preview)</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="../resources/jdk-default.css" />
  <link rel="stylesheet" href="../resources/spec-changes.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>

<header id="title-block-header">
<div class="navbar"><div><strong>Java SE 20 & JDK 20</strong></div><nav><ul><li><a href="../api/index.html">API</a>
<li><a href="index.html">OTHER SPECIFICATIONS</a>
<li><a href="man/index.html">TOOL GUIDES</a></ul></nav></div>

<h1 class="title">Pattern Matching for <code>switch</code> (Fourth
Preview) and Record Patterns (Second Preview)</h1>
<p class="subtitle">Changes to the Java® Language Specification •
Version 20+36-2344</p>
</header>
<nav id="TOC" role="doc-toc" title="Table Of Contents">
<ul>
<li><a href="#jls-3" id="toc-jls-3">Chapter 3: Lexical Structure</a>
<ul>
<li><a href="#jls-3.9" id="toc-jls-3.9">3.9 Keywords</a></li>
</ul></li>
<li><a href="#jls-5" id="toc-jls-5">Chapter 5: Conversions and
Contexts</a>
<ul>
<li><a href="#jls-5.5" id="toc-jls-5.5">5.5 Casting Contexts</a></li>
</ul></li>
<li><a href="#jls-6" id="toc-jls-6">Chapter 6: Names</a>
<ul>
<li><a href="#jls-6.3" id="toc-jls-6.3">6.3 Scope of a Declaration</a>
<ul>
<li><a href="#jls-6.3.1" id="toc-jls-6.3.1">6.3.1 Scope for Pattern
Variables in Expressions</a>
<ul>
<li><a href="#jls-6.3.1.6" id="toc-jls-6.3.1.6">6.3.1.6
<code>switch</code> Expressions</a></li>
</ul></li>
<li><a href="#jls-6.3.2" id="toc-jls-6.3.2">6.3.2 Scope for Pattern
Variables in Statements</a>
<ul>
<li><a href="#jls-6.3.2.5" id="toc-jls-6.3.2.5">6.3.2.5 <code>for</code>
Statements</a></li>
<li><a href="#jls-6.3.2.6" id="toc-jls-6.3.2.6">6.3.2.6
<code>switch</code> Statements</a></li>
</ul></li>
<li><a href="#jls-6.3.3" id="toc-jls-6.3.3"><strong>6.3.3 Scope for
Pattern Variables in Patterns</strong></a>
<ul>
<li><a href="#jls-6.3.3.1" id="toc-jls-6.3.3.1"><strong>6.3.3.1 Record
Patterns</strong></a></li>
</ul></li>
<li><a href="#jls-6.3.4" id="toc-jls-6.3.4"><strong>6.3.4 Scope for
Pattern Variables in Switch Labels</strong></a></li>
</ul></li>
</ul></li>
<li><a href="#jls-13" id="toc-jls-13">Chapter 13: Binary
Compatibility</a>
<ul>
<li><a href="#jls-13.4" id="toc-jls-13.4">13.4 Evolution of Classes</a>
<ul>
<li><a href="#jls-13.4.2" id="toc-jls-13.4.2">13.4.2
<code>sealed</code>, <code>non-sealed</code>, and <code>final</code>
Classes</a>
<ul>
<li><a href="#jls-13.4.2.1" id="toc-jls-13.4.2.1">13.4.2.1
<code>sealed</code> Classes</a></li>
</ul></li>
<li><a href="#jls-13.4.26" id="toc-jls-13.4.26">13.4.26 Evolution of
Enum Classes</a></li>
</ul></li>
<li><a href="#jls-13.5" id="toc-jls-13.5">13.5 Evolution of
Interfaces</a>
<ul>
<li><a href="#jls-13.5.2" id="toc-jls-13.5.2">13.5.2 <code>sealed</code>
and <code>non-sealed</code> Interfaces</a></li>
</ul></li>
</ul></li>
<li><a href="#jls-14" id="toc-jls-14">Chapter 14: Blocks, Statements,
and Patterns</a>
<ul>
<li><a href="#jls-14.11" id="toc-jls-14.11">14.11 The
<code>switch</code> Statement</a>
<ul>
<li><a href="#jls-14.11.1" id="toc-jls-14.11.1">14.11.1 Switch
Blocks</a>
<ul>
<li><a href="#jls-14.11.1.1" id="toc-jls-14.11.1.1"><strong>14.11.1.1
Exhaustive Switch Blocks</strong></a></li>
<li><a href="#jls-14.11.1.2" id="toc-jls-14.11.1.2"><strong>14.11.1.2
Executable Switch Blocks and Determining which Switch Label Applies at
Run-Time</strong></a></li>
</ul></li>
<li><a href="#jls-14.11.2" id="toc-jls-14.11.2">14.11.2 The Switch Block
of a <code>switch</code> Statement</a></li>
<li><a href="#jls-14.11.3" id="toc-jls-14.11.3">14.11.3 Execution of a
<code>switch</code> Statement</a></li>
</ul></li>
<li><a href="#jls-14.14" id="toc-jls-14.14">14.14 The <code>for</code>
Statement</a>
<ul>
<li><a href="#jls-14.14.2" id="toc-jls-14.14.2">14.14.2 The enhanced
<code>for</code> statement</a></li>
</ul></li>
<li><a href="#jls-14.30" id="toc-jls-14.30">14.30 Patterns</a>
<ul>
<li><a href="#jls-14.30.1" id="toc-jls-14.30.1">14.30.1 Kinds of
Patterns</a></li>
<li><a href="#jls-14.30.2" id="toc-jls-14.30.2">14.30.2 Pattern
Matching</a></li>
<li><a href="#jls-14.30.3" id="toc-jls-14.30.3"><strong>14.30.3
Properties of Patterns</strong></a></li>
</ul></li>
</ul></li>
<li><a href="#jls-15" id="toc-jls-15">Chapter 15: Expressions</a>
<ul>
<li><a href="#jls-15.20" id="toc-jls-15.20">15.20 Relational
Operators</a>
<ul>
<li><a href="#jls-15.20.2" id="toc-jls-15.20.2">15.20.2 The
<code>instanceof</code> Operator</a></li>
</ul></li>
<li><a href="#jls-15.28" id="toc-jls-15.28">15.28 <code>switch</code>
Expressions</a>
<ul>
<li><a href="#jls-15.28.1" id="toc-jls-15.28.1">15.28.1 The Switch Block
of a <code>switch</code> Expression</a></li>
<li><a href="#jls-15.28.2" id="toc-jls-15.28.2">15.28.2 Run-Time
Evaluation of <code>switch</code> Expressions</a></li>
</ul></li>
</ul></li>
<li><a href="#jls-16" id="toc-jls-16">Chapter 16: Definite
Assignment</a>
<ul>
<li><a href="#jls-16.2" id="toc-jls-16.2">16.2 Definite Assignment and
Statements</a>
<ul>
<li><a href="#jls-16.2.9" id="toc-jls-16.2.9">16.2.9 <code>switch</code>
Statements</a></li>
</ul></li>
</ul></li>
<li><a href="#jls-18" id="toc-jls-18">Chapter 18: Type Inference</a>
<ul>
<li><a href="#jls-18.5" id="toc-jls-18.5">18.5 Uses of Inference</a>
<ul>
<li><a href="#jls-18.5.5" id="toc-jls-18.5.5"><strong>18.5.5 Record
Pattern Type Inference</strong></a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<main><p>This document describes changes to the <a
href="https://docs.oracle.com/javase/specs/jls/se19/html">Java Language Specification</a>
to support <em>Pattern Matching for <code>switch</code></em> and
<em>Record Patterns</em>, which are both preview features of Java SE 20.
See <a href="https://openjdk.org/jeps/433">JEP 433</a> and <a
href="https://openjdk.org/jeps/432">JEP 432</a> respectively for
overviews of the features.</p>
<p>Changes are described with respect to existing sections of the JLS.
New text is indicated <strong>like this</strong> and deleted text is
indicated <del>like this</del>. Explanation and discussion, as needed,
is set aside in grey boxes.</p>
<div class="editorial">
<p>Changelog:</p>
<p>2022-11-15:</p>
<ul>
<li><p>A <code>switch</code> expression over an enum class now throws
<code>MatchException</code>, rather than
<code>IncompatibleClassChangeError</code>, if no switch label applies at
runtime.</p></li>
<li><p>Improvements to example of inference of type arguments for record
patterns.</p></li>
</ul>
<p>2022-10-28: Added details of inference of type arguments for record
patterns.</p>
<p>2022-10-18: First draft released. Main changes from the third preview
specification, in addition to various bug-fixes, are:</p>
<ul>
<li>A simplified grammar for switch labels.</li>
<li>New support for record patterns to appear in the header of an
enhanced <code>for</code> statement.</li>
<li>Named record patterns have been removed.</li>
<li>The test determining whether a switch block is exhaustive has been
strengthened.</li>
</ul>
</div>
<h2 id="jls-3">Chapter 3: Lexical Structure</h2>
<h3 id="jls-3.9">3.9 Keywords</h3>
<p>51 character sequences, formed from ASCII characters, are reserved
for use as keywords and cannot be used as identifiers (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-3.html#jls-3.8">3.8</a>).
Another 16 character sequences, also formed from ASCII characters, may
be interpreted as keywords or as other tokens, depending on the context
in which they appear.</p>
<dl>
<dt><em>Keyword:</em></dt>
<dd>
<em>ReservedKeyword</em>
</dd>
<dd>
<em>ContextualKeyword</em>
</dd>
<dt><em>ReservedKeyword:</em></dt>
<dd>
(one of)
</dd>
<dd>
<code>abstract continue for new switch</code><br />
<code>assert default if package synchronized</code><br />
<code>boolean do goto private this</code><br />
<code>break double implements protected throw</code><br />
<code>byte else import public throws</code><br />
<code>case enum instanceof return transient</code><br />
<code>catch extends int short try</code><br />
<code>char final interface static void</code><br />
<code>class finally long strictfp volatile</code><br />
<code>const float native super while</code><br />
<code>_</code> (underscore)
</dd>
<dt><em>ContextualKeyword:</em></dt>
<dd>
(one of)
</dd>
<dd>
<code>exports    permits  to          with</code><br />
<code>module     provides transitive  yield</code><br />
<code>non-sealed record   uses</code><br />
<code>open       requires var</code><br />
<code>opens      sealed</code> <strong><code>when</code></strong>
</dd>
</dl>
<blockquote>
<p>The keywords <code>const</code> and <code>goto</code> are reserved,
even though they are not currently used. This may allow a Java compiler
to produce better error messages if these C++ keywords incorrectly
appear in programs.</p>
</blockquote>
<blockquote>
<p>The keyword <code>strictfp</code> is obsolete and should not be used
in new code.</p>
</blockquote>
<blockquote>
<p>The keyword <code>_</code> (underscore) is reserved for possible
future use in parameter declarations.</p>
</blockquote>
<blockquote>
<p><code>true</code> and <code>false</code> are not keywords, but rather
boolean literals (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-3.html#jls-3.10.3">3.10.3</a>).</p>
</blockquote>
<blockquote>
<p><code>null</code> is not a keyword, but rather the null literal (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-3.html#jls-3.10.8">3.10.8</a>).</p>
</blockquote>
<p>During the reduction of input characters to input elements (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-3.html#jls-3.5">3.5</a>),
a sequence of input characters that notionally matches a contextual
keyword is reduced to a contextual keyword if and only if both of the
following conditions hold:</p>
<ol type="1">
<li><p>The sequence is recognized as a terminal specified in a suitable
context of the syntactic grammar (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-2.html#jls-2.3">2.3</a>),
as follows:</p>
<ul>
<li><p>For <code>module</code> and <code>open</code>, when recognized as
a terminal in a <em>ModuleDeclaration</em> (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-7.html#jls-7.7">7.7</a>).</p></li>
<li><p>For <code>exports</code>, <code>opens</code>,
<code>provides</code>, <code>requires</code>, <code>to</code>,
<code>uses</code>, and <code>with</code>, when recognized as a terminal
in a <em>ModuleDirective</em>.</p></li>
<li><p>For <code>transitive</code>, when recognized as a terminal in a
<em>RequiresModifier</em>.</p>
<blockquote>
<p>For example, recognizing the sequence <code>requires</code>
<code>transitive</code> <code>;</code> does not make use of
<em>RequiresModifier</em>, so the term <code>transitive</code> is
reduced here to an identifier and not a contextual keyword.</p>
</blockquote></li>
<li><p>For <code>var</code>, when recognized as a terminal in a
<em>LocalVariableType</em> (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-14.html#jls-14.4">14.4</a>)
or a <em>LambdaParameterType</em> (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-15.html#jls-15.27.1">15.27.1</a>).</p>
<blockquote>
<p>In other contexts, attempting to use <code>var</code> as an
identifier will cause an error, because <code>var</code> is not a
<em>TypeIdentifier</em> (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-3.html#jls-3.8">3.8</a>).</p>
</blockquote></li>
<li><p>For <code>yield</code>, when recognized as a terminal in a
<em>YieldStatement</em> (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-14.html#jls-14.21">14.21</a>).</p>
<blockquote>
<p>In other contexts, attempting to use the <code>yield</code> as an
identifier will cause an error, because <code>yield</code> is neither a
<em>TypeIdentifier</em> nor a <em>UnqualifiedMethodIdentifier</em>.</p>
</blockquote></li>
<li><p>For <code>record</code>, when recognized as a terminal in a
<em>RecordDeclaration</em> (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-8.html#jls-8.10">8.10</a>).</p></li>
<li><p>For <code>non-sealed</code>, <code>permits</code>, and
<code>sealed</code>, when recognized as a terminal in a
<em>NormalClassDeclaration</em> (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-8.html#jls-8.1">8.1</a>)
or a <em>NormalInterfaceDeclaration</em> (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-9.html#jls-9.1">9.1</a>).</p></li>
<li><p><strong>For <code>when</code>, when recognized as a terminal in a
<em>Guard</em> (<a href="#jls-14.11.1">14.11.1</a>).</strong></p></li>
</ul></li>
<li><p>The sequence is not immediately preceded or immediately followed
by an input character that matches <em>JavaLetterOrDigit</em>.</p></li>
</ol>
<blockquote>
<p>In general, accidentally omitting white space in source code will
cause a sequence of input characters to be tokenized as an identifier,
due to the "longest possible translation" rule (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-3.html#jls-3.2">3.2</a>).
For example, the sequence of twelve input characters
<code>p u b l i c s t a t i c</code> is always tokenized as the
identifier <code>publicstatic</code>, rather than as the reserved
keywords <code>public</code> and <code>static</code>. If two tokens are
intended, they must be separated by white space or a comment.</p>
</blockquote>
<blockquote>
<p>The rule above works in tandem with the "longest possible
translation" rule to produce an intuitive result in contexts where
contextual keywords may appear. For example, the sequence of eleven
input characters <code>v a r f i l e n a m e</code> is usually tokenized
as the identifier <code>varfilename</code>, but in a local variable
declaration, the first three input characters are tentatively recognized
as the contextual keyword <code>var</code> by the first condition of the
rule above. However, it would be confusing to overlook the lack of white
space in the sequence by recognizing the next eight input characters as
the identifier <code>filename</code>. (This would mean that the sequence
undergoes different tokenization in different contexts: an identifier in
most contexts, but a contextual keyword and an identifier in local
variable declarations.) Accordingly, the second condition prevents
recognition of the contextual keyword <code>var</code> on the grounds
that the immediately following input character <code>f</code> is a
<em>JavaLetterOrDigit</em>. The sequence
<code>v a r f i l e n a m e</code> is therefore tokenized as the
identifier <code>varfilename</code> in a local variable declaration.</p>
</blockquote>
<blockquote>
<p>As another example of the careful recognition of contextual keywords,
consider the sequence of 15 input characters
<code>n o n - s e a l e d c l a s s</code>. This sequence is usually
translated to three tokens - the identifier <code>non</code>, the
operator <code>-</code>, and the identifier <code>sealedclass</code> -
but in a normal class declaration, where the first condition holds, the
first ten input characters are tentatively recognized as the contextual
keyword <code>non-sealed</code>. To avoid translating the sequence to
two keyword tokens (<code>non-sealed</code> and <code>class</code>)
rather than three non-keyword tokens, and to avoid rewarding the
programmer for omitting white space before <code>class</code>, the
second condition prevents recognition of the contextual keyword. The
sequence <code>n o n - s e a l e d c l a s s</code> is therefore
tokenized as three tokens in a class declaration.</p>
</blockquote>
<blockquote>
<p>In the rule above, the first condition depends on details of the
syntactic grammar, but a compiler for the Java programming language can
implement the rule without fully parsing the input program. For example,
a heuristic could be used to track the contextual state of the
tokenizer, as long as the heuristic guarantees that valid uses of
contextual keywords are tokenized as keywords, and valid uses of
identifiers are tokenized as identifiers. Alternatively, a compiler
could always tokenize a contextual keyword as an identifier, leaving it
to a later phase to recognize special uses of these identifiers.</p>
</blockquote>
<h2 id="jls-5">Chapter 5: Conversions and Contexts</h2>
<h3 id="jls-5.5">5.5 Casting Contexts</h3>
<p><em>Casting contexts</em> allow the operand of a cast expression (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-15.html#jls-15.16">15.16</a>)
to be converted to the type explicitly named by the cast operator.
Compared to assignment contexts and invocation contexts, casting
contexts allow the use of more of the conversions defined in <a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-5.html#jls-5.1">5.1</a>,
and allow more combinations of those conversions.</p>
<p>If the expression is of a primitive type, then a casting context
allows the use of one of the following:</p>
<ul>
<li><p>an identity conversion (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-5.html#jls-5.1.1">5.1.1</a>)</p></li>
<li><p>a widening primitive conversion (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-5.html#jls-5.1.2">5.1.2</a>)</p></li>
<li><p>a narrowing primitive conversion (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-5.html#jls-5.1.3">5.1.3</a>)</p></li>
<li><p>a widening and narrowing primitive conversion (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-5.html#jls-5.1.4">5.1.4</a>)</p></li>
<li><p>a boxing conversion (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-5.html#jls-5.1.7">5.1.7</a>)</p></li>
<li><p>a boxing conversion followed by a widening reference conversion
(<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-5.html#jls-5.1.5">5.1.5</a>)</p></li>
</ul>
<p>If the expression is of a reference type, then a casting context
allows the use of one of the following:</p>
<ul>
<li><p>an identity conversion (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-5.html#jls-5.1.1">5.1.1</a>)</p></li>
<li><p>a widening reference conversion (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-5.html#jls-5.1.5">5.1.5</a>)</p></li>
<li><p>a widening reference conversion followed by an unboxing
conversion</p></li>
<li><p>a widening reference conversion followed by an unboxing
conversion, then followed by a widening primitive conversion</p></li>
<li><p>a narrowing reference conversion (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-5.html#jls-5.1.6">5.1.6</a>)</p></li>
<li><p>a narrowing reference conversion followed by an unboxing
conversion</p></li>
<li><p>an unboxing conversion (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-5.html#jls-5.1.8">5.1.8</a>)</p></li>
<li><p>an unboxing conversion followed by a widening primitive
conversion</p></li>
</ul>
<p>If the expression has the null type, then the expression may be cast
to any reference type.</p>
<p>If a casting context makes use of a narrowing reference conversion
that is checked or partially unchecked (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-5.html#jls-5.1.6.2">5.1.6.2</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-5.html#jls-5.1.6.3">5.1.6.3</a>),
then a run time check will be performed on the class of the expression's
value, possibly causing a <code>ClassCastException</code>. Otherwise, no
run time check is performed.</p>
<p>If an expression can be converted to a reference type by a casting
conversion <em>other than a narrowing reference conversion which is
unchecked</em>, we say the expression (or its value) is <em>downcast
compatible with</em> the reference type.</p>
<div class="inserted">
<p>If an expression of reference type <em>S</em> is downcast compatible
with another reference type <em>T</em>, we say that the type <em>S</em>
is <em>downcast convertible</em> to type <em>T</em>.</p>
</div>
<p>The following tables enumerate which conversions are used in certain
casting contexts. Each conversion is signified by a symbol:</p>
<ul>
<li><p><em>-</em> signifies no conversion allowed</p></li>
<li><p><em>≈</em> signifies identity conversion (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-5.html#jls-5.1.1">5.1.1</a>)</p></li>
<li><p><em>ω</em> signifies widening primitive conversion (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-5.html#jls-5.1.2">5.1.2</a>)</p></li>
<li><p><em>η</em> signifies narrowing primitive conversion (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-5.html#jls-5.1.3">5.1.3</a>)</p></li>
<li><p><em>ωη</em> signifies widening and narrowing primitive conversion
(<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-5.html#jls-5.1.4">5.1.4</a>)</p></li>
<li><p><em>⇑</em> signifies widening reference conversion (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-5.html#jls-5.1.5">5.1.5</a>)</p></li>
<li><p><em>⇓</em> signifies narrowing reference conversion (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-5.html#jls-5.1.6">5.1.6</a>)</p></li>
<li><p><em>⊕</em> signifies boxing conversion (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-5.html#jls-5.1.7">5.1.7</a>)</p></li>
<li><p><em>⊗</em> signifies unboxing conversion (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-5.html#jls-5.1.8">5.1.8</a>)</p></li>
</ul>
<p>In the tables, a comma between symbols indicates that a casting
context uses one conversion followed by another. The type
<code>Object</code> means any reference type other than the eight
wrapper classes <code>Boolean</code>, <code>Byte</code>,
<code>Short</code>, <code>Character</code>, <code>Integer</code>,
<code>Long</code>, <code>Float</code>, <code>Double</code>.</p>
<div id="jls-5.5-320" class="table">
<p>Table 5.5-A. Casting to primitive types</p>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 11%" />
<col style="width: 12%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">To <em>→</em><br />
From <em>↓</em></th>
<th style="text-align: left;"><code>byte</code></th>
<th style="text-align: left;"><code>short</code></th>
<th style="text-align: left;"><code>char</code></th>
<th style="text-align: left;"><code>int</code></th>
<th style="text-align: left;"><code>long</code></th>
<th style="text-align: left;"><code>float</code></th>
<th style="text-align: left;"><code>double</code></th>
<th style="text-align: left;"><code>boolean</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<th style="font-weight: normal; text-align: left;" scope="row"><code>byte</code></th>
<td style="text-align: left;"><em>≈</em></td>
<td style="text-align: left;"><em>ω</em></td>
<td style="text-align: left;"><em>ωη</em></td>
<td style="text-align: left;"><em>ω</em></td>
<td style="text-align: left;"><em>ω</em></td>
<td style="text-align: left;"><em>ω</em></td>
<td style="text-align: left;"><em>ω</em></td>
<td style="text-align: left;">-</td>
</tr>
<tr class="even">
<th style="font-weight: normal; text-align: left;" scope="row"><code>short</code></th>
<td style="text-align: left;"><em>η</em></td>
<td style="text-align: left;"><em>≈</em></td>
<td style="text-align: left;"><em>η</em></td>
<td style="text-align: left;"><em>ω</em></td>
<td style="text-align: left;"><em>ω</em></td>
<td style="text-align: left;"><em>ω</em></td>
<td style="text-align: left;"><em>ω</em></td>
<td style="text-align: left;">-</td>
</tr>
<tr class="odd">
<th style="font-weight: normal; text-align: left;" scope="row"><code>char</code></th>
<td style="text-align: left;"><em>η</em></td>
<td style="text-align: left;"><em>η</em></td>
<td style="text-align: left;"><em>≈</em></td>
<td style="text-align: left;"><em>ω</em></td>
<td style="text-align: left;"><em>ω</em></td>
<td style="text-align: left;"><em>ω</em></td>
<td style="text-align: left;"><em>ω</em></td>
<td style="text-align: left;">-</td>
</tr>
<tr class="even">
<th style="font-weight: normal; text-align: left;" scope="row"><code>int</code></th>
<td style="text-align: left;"><em>η</em></td>
<td style="text-align: left;"><em>η</em></td>
<td style="text-align: left;"><em>η</em></td>
<td style="text-align: left;"><em>≈</em></td>
<td style="text-align: left;"><em>ω</em></td>
<td style="text-align: left;"><em>ω</em></td>
<td style="text-align: left;"><em>ω</em></td>
<td style="text-align: left;">-</td>
</tr>
<tr class="odd">
<th style="font-weight: normal; text-align: left;" scope="row"><code>long</code></th>
<td style="text-align: left;"><em>η</em></td>
<td style="text-align: left;"><em>η</em></td>
<td style="text-align: left;"><em>η</em></td>
<td style="text-align: left;"><em>η</em></td>
<td style="text-align: left;"><em>≈</em></td>
<td style="text-align: left;"><em>ω</em></td>
<td style="text-align: left;"><em>ω</em></td>
<td style="text-align: left;">-</td>
</tr>
<tr class="even">
<th style="font-weight: normal; text-align: left;" scope="row"><code>float</code></th>
<td style="text-align: left;"><em>η</em></td>
<td style="text-align: left;"><em>η</em></td>
<td style="text-align: left;"><em>η</em></td>
<td style="text-align: left;"><em>η</em></td>
<td style="text-align: left;"><em>η</em></td>
<td style="text-align: left;"><em>≈</em></td>
<td style="text-align: left;"><em>ω</em></td>
<td style="text-align: left;">-</td>
</tr>
<tr class="odd">
<th style="font-weight: normal; text-align: left;" scope="row"><code>double</code></th>
<td style="text-align: left;"><em>η</em></td>
<td style="text-align: left;"><em>η</em></td>
<td style="text-align: left;"><em>η</em></td>
<td style="text-align: left;"><em>η</em></td>
<td style="text-align: left;"><em>η</em></td>
<td style="text-align: left;"><em>η</em></td>
<td style="text-align: left;"><em>≈</em></td>
<td style="text-align: left;">-</td>
</tr>
<tr class="even">
<th style="font-weight: normal; text-align: left;" scope="row"><code>boolean</code></th>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;"><em>≈</em></td>
</tr>
<tr class="odd">
<th style="font-weight: normal; text-align: left;" scope="row"><code>Byte</code></th>
<td style="text-align: left;"><em>⊗</em></td>
<td style="text-align: left;"><em>⊗</em>,<em>ω</em></td>
<td style="text-align: left;">-</td>
<td style="text-align: left;"><em>⊗</em>,<em>ω</em></td>
<td style="text-align: left;"><em>⊗</em>,<em>ω</em></td>
<td style="text-align: left;"><em>⊗</em>,<em>ω</em></td>
<td style="text-align: left;"><em>⊗</em>,<em>ω</em></td>
<td style="text-align: left;">-</td>
</tr>
<tr class="even">
<th style="font-weight: normal; text-align: left;" scope="row"><code>Short</code></th>
<td style="text-align: left;">-</td>
<td style="text-align: left;"><em>⊗</em></td>
<td style="text-align: left;">-</td>
<td style="text-align: left;"><em>⊗</em>,<em>ω</em></td>
<td style="text-align: left;"><em>⊗</em>,<em>ω</em></td>
<td style="text-align: left;"><em>⊗</em>,<em>ω</em></td>
<td style="text-align: left;"><em>⊗</em>,<em>ω</em></td>
<td style="text-align: left;">-</td>
</tr>
<tr class="odd">
<th style="font-weight: normal; text-align: left;" scope="row"><code>Character</code></th>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;"><em>⊗</em></td>
<td style="text-align: left;"><em>⊗</em>,<em>ω</em></td>
<td style="text-align: left;"><em>⊗</em>,<em>ω</em></td>
<td style="text-align: left;"><em>⊗</em>,<em>ω</em></td>
<td style="text-align: left;"><em>⊗</em>,<em>ω</em></td>
<td style="text-align: left;">-</td>
</tr>
<tr class="even">
<th style="font-weight: normal; text-align: left;" scope="row"><code>Integer</code></th>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;"><em>⊗</em></td>
<td style="text-align: left;"><em>⊗</em>,<em>ω</em></td>
<td style="text-align: left;"><em>⊗</em>,<em>ω</em></td>
<td style="text-align: left;"><em>⊗</em>,<em>ω</em></td>
<td style="text-align: left;">-</td>
</tr>
<tr class="odd">
<th style="font-weight: normal; text-align: left;" scope="row"><code>Long</code></th>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;"><em>⊗</em></td>
<td style="text-align: left;"><em>⊗</em>,<em>ω</em></td>
<td style="text-align: left;"><em>⊗</em>,<em>ω</em></td>
<td style="text-align: left;">-</td>
</tr>
<tr class="even">
<th style="font-weight: normal; text-align: left;" scope="row"><code>Float</code></th>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;"><em>⊗</em></td>
<td style="text-align: left;"><em>⊗</em>,<em>ω</em></td>
<td style="text-align: left;">-</td>
</tr>
<tr class="odd">
<th style="font-weight: normal; text-align: left;" scope="row"><code>Double</code></th>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;"><em>⊗</em></td>
<td style="text-align: left;">-</td>
</tr>
<tr class="even">
<th style="font-weight: normal; text-align: left;" scope="row"><code>Boolean</code></th>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;"><em>⊗</em></td>
</tr>
<tr class="odd">
<th style="font-weight: normal; text-align: left;" scope="row"><code>Object</code></th>
<td style="text-align: left;"><em>⇓</em>,<em>⊗</em></td>
<td style="text-align: left;"><em>⇓</em>,<em>⊗</em></td>
<td style="text-align: left;"><em>⇓</em>,<em>⊗</em></td>
<td style="text-align: left;"><em>⇓</em>,<em>⊗</em></td>
<td style="text-align: left;"><em>⇓</em>,<em>⊗</em></td>
<td style="text-align: left;"><em>⇓</em>,<em>⊗</em></td>
<td style="text-align: left;"><em>⇓</em>,<em>⊗</em></td>
<td style="text-align: left;"><em>⇓</em>,<em>⊗</em></td>
</tr>
</tbody>
</table>
</div>
<div id="jls-5.5-330" class="table">
<p>Table 5.5-B. Casting to reference types</p>
<table style="width:100%;">
<colgroup>
<col style="width: 12%" />
<col style="width: 7%" />
<col style="width: 8%" />
<col style="width: 12%" />
<col style="width: 10%" />
<col style="width: 7%" />
<col style="width: 8%" />
<col style="width: 9%" />
<col style="width: 10%" />
<col style="width: 10%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">To <em>→</em><br />
From <em>↓</em></th>
<th style="text-align: left;"><code>Byte</code></th>
<th style="text-align: left;"><code>Short</code></th>
<th style="text-align: left;"><code>Character</code></th>
<th style="text-align: left;"><code>Integer</code></th>
<th style="text-align: left;"><code>Long</code></th>
<th style="text-align: left;"><code>Float</code></th>
<th style="text-align: left;"><code>Double</code></th>
<th style="text-align: left;"><code>Boolean</code></th>
<th style="text-align: left;"><code>Object</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<th style="font-weight: normal; text-align: left;" scope="row"><code>byte</code></th>
<td style="text-align: left;"><em>⊕</em></td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;"><em>⊕</em>,<em>⇑</em></td>
</tr>
<tr class="even">
<th style="font-weight: normal; text-align: left;" scope="row"><code>short</code></th>
<td style="text-align: left;">-</td>
<td style="text-align: left;"><em>⊕</em></td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;"><em>⊕</em>,<em>⇑</em></td>
</tr>
<tr class="odd">
<th style="font-weight: normal; text-align: left;" scope="row"><code>char</code></th>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;"><em>⊕</em></td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;"><em>⊕</em>,<em>⇑</em></td>
</tr>
<tr class="even">
<th style="font-weight: normal; text-align: left;" scope="row"><code>int</code></th>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;"><em>⊕</em></td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;"><em>⊕</em>,<em>⇑</em></td>
</tr>
<tr class="odd">
<th style="font-weight: normal; text-align: left;" scope="row"><code>long</code></th>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;"><em>⊕</em></td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;"><em>⊕</em>,<em>⇑</em></td>
</tr>
<tr class="even">
<th style="font-weight: normal; text-align: left;" scope="row"><code>float</code></th>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;"><em>⊕</em></td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;"><em>⊕</em>,<em>⇑</em></td>
</tr>
<tr class="odd">
<th style="font-weight: normal; text-align: left;" scope="row"><code>double</code></th>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;"><em>⊕</em></td>
<td style="text-align: left;">-</td>
<td style="text-align: left;"><em>⊕</em>,<em>⇑</em></td>
</tr>
<tr class="even">
<th style="font-weight: normal; text-align: left;" scope="row"><code>boolean</code></th>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;"><em>⊕</em></td>
<td style="text-align: left;"><em>⊕</em>,<em>⇑</em></td>
</tr>
<tr class="odd">
<th style="font-weight: normal; text-align: left;" scope="row"><code>Byte</code></th>
<td style="text-align: left;"><em>≈</em></td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;"><em>⇑</em></td>
</tr>
<tr class="even">
<th style="font-weight: normal; text-align: left;" scope="row"><code>Short</code></th>
<td style="text-align: left;">-</td>
<td style="text-align: left;"><em>≈</em></td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;"><em>⇑</em></td>
</tr>
<tr class="odd">
<th style="font-weight: normal; text-align: left;" scope="row"><code>Character</code></th>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;"><em>≈</em></td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;"><em>⇑</em></td>
</tr>
<tr class="even">
<th style="font-weight: normal; text-align: left;" scope="row"><code>Integer</code></th>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;"><em>≈</em></td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;"><em>⇑</em></td>
</tr>
<tr class="odd">
<th style="font-weight: normal; text-align: left;" scope="row"><code>Long</code></th>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;"><em>≈</em></td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;"><em>⇑</em></td>
</tr>
<tr class="even">
<th style="font-weight: normal; text-align: left;" scope="row"><code>Float</code></th>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;"><em>≈</em></td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;"><em>⇑</em></td>
</tr>
<tr class="odd">
<th style="font-weight: normal; text-align: left;" scope="row"><code>Double</code></th>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;"><em>≈</em></td>
<td style="text-align: left;">-</td>
<td style="text-align: left;"><em>⇑</em></td>
</tr>
<tr class="even">
<th style="font-weight: normal; text-align: left;" scope="row"><code>Boolean</code></th>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;"><em>≈</em></td>
<td style="text-align: left;"><em>⇑</em></td>
</tr>
<tr class="odd">
<th style="font-weight: normal; text-align: left;" scope="row"><code>Object</code></th>
<td style="text-align: left;"><em>⇓</em></td>
<td style="text-align: left;"><em>⇓</em></td>
<td style="text-align: left;"><em>⇓</em></td>
<td style="text-align: left;"><em>⇓</em></td>
<td style="text-align: left;"><em>⇓</em></td>
<td style="text-align: left;"><em>⇓</em></td>
<td style="text-align: left;"><em>⇓</em></td>
<td style="text-align: left;"><em>⇓</em></td>
<td style="text-align: left;"><em>≈</em></td>
</tr>
</tbody>
</table>
</div>
<div class="example">
<p>Example 5.5-1. Casting for Reference Types</p>
<pre><code>class Point { int x, y; }
interface Colorable { void setColor(int color); }
class ColoredPoint extends Point implements Colorable {
    int color;
    public void setColor(int color) { this.color = color; }
}
final class EndPoint extends Point {}

class Test {
    public static void main(String[] args) {
        Point p = new Point();
        ColoredPoint cp = new ColoredPoint();
        Colorable c;
        // The following may cause errors at run time because
        // we cannot be sure they will succeed; this possibility
        // is suggested by the casts:
        cp = (ColoredPoint)p;  // p might not reference an
                               // object which is a ColoredPoint
                               // or a subclass of ColoredPoint
        c = (Colorable)p;      // p might not be Colorable
        // The following are incorrect at compile time because
        // they can never succeed as explained in the text:
        Long l = (Long)p;            // compile-time error #1
        EndPoint e = new EndPoint();
        c = (Colorable)e;            // compile-time error #2
    }
}</code></pre>
<p>Here, the first compile-time error occurs because the class types
<code>Long</code> and <code>Point</code> are unrelated (that is, they
are not the same, and neither is a subclass of the other), so a cast
between them will always fail.</p>
<p>The second compile-time error occurs because a variable of type
<code>EndPoint</code> can never reference a value that implements the
interface <code>Colorable</code>. This is because <code>EndPoint</code>
is a <code>final</code> type, and a variable of a <code>final</code>
type always holds a value of the same run-time type as its compile-time
type. Therefore, the run-time type of variable <code>e</code> must be
exactly the type <code>EndPoint</code>, and type <code>EndPoint</code>
does not implement <code>Colorable</code>.</p>
</div>
<div class="example">
<p>Example 5.5-2. Casting for Array Types</p>
<pre><code>class Point {
    int x, y;
    Point(int x, int y) { this.x = x; this.y = y; }
    public String toString() { return &quot;(&quot;+x+&quot;,&quot;+y+&quot;)&quot;; }
}
interface Colorable { void setColor(int color); }
class ColoredPoint extends Point implements Colorable {
    int color;
    ColoredPoint(int x, int y, int color) {
        super(x, y); setColor(color);
    }
    public void setColor(int color) { this.color = color; }
    public String toString() {
        return super.toString() + &quot;@&quot; + color;
    }
}

class Test {
    public static void main(String[] args) {
        Point[] pa = new ColoredPoint[4];
        pa[0] = new ColoredPoint(2, 2, 12);
        pa[1] = new ColoredPoint(4, 5, 24);
        ColoredPoint[] cpa = (ColoredPoint[])pa;
        System.out.print(&quot;cpa: {&quot;);
        for (int i = 0; i &lt; cpa.length; i++)
            System.out.print((i == 0 ? &quot; &quot; : &quot;, &quot;) + cpa[i]);
        System.out.println(&quot; }&quot;);
    }
}</code></pre>
<p>This program compiles without errors and produces the output:</p>
<pre><code>cpa: { (2,2)@12, (4,5)@24, null, null }</code></pre>
</div>
<div class="example">
<p>Example 5.5-3. Casting Incompatible Types at Run Time</p>
<pre><code>class Point { int x, y; }
interface Colorable { void setColor(int color); }
class ColoredPoint extends Point implements Colorable {
    int color;
    public void setColor(int color) { this.color = color; }
}

class Test {
    public static void main(String[] args) {
        Point[] pa = new Point[100];

        // The following line will throw a ClassCastException:
        ColoredPoint[] cpa = (ColoredPoint[])pa;
        System.out.println(cpa[0]);
        int[] shortvec = new int[2];
        Object o = shortvec;

        // The following line will throw a ClassCastException:
        Colorable c = (Colorable)o;
        c.setColor(0);
    }
}</code></pre>
<p>This program uses casts to compile, but it throws exceptions at run
time, because the types are incompatible.</p>
</div>
<h2 id="jls-6">Chapter 6: Names</h2>
<h3 id="jls-6.3">6.3 Scope of a Declaration</h3>
<h4 id="jls-6.3.1">6.3.1 Scope for Pattern Variables in Expressions</h4>
<h5 id="jls-6.3.1.6">6.3.1.6 <code>switch</code> Expressions</h5>
<p>The following <del>rule applies</del> <strong>rules apply</strong> to
a <code>switch</code> expression <del>(<a
href="#jls-15.28">15.28</a>)</del> <strong>with a switch block
consisting of switch rules (<a
href="#jls-14.11.1">14.11.1</a>)</strong>:</p>
<div class="inserted">
<ul>
<li><p>A pattern variable introduced by a switch label is definitely
matched in the associated switch rule expression, switch rule block, or
switch rule <code>throw</code> statement.</p>
<p>It is a compile-time error if any pattern variable introduced by a
switch label is already in scope at the associated switch rule
expression, switch rule block, or switch rule <code>throw</code>
statement.</p></li>
</ul>
<p>The following rules apply to a switch expression with a switch block
consisting of switch labeled statement groups (<a
href="#jls-14.11.1">14.11.1</a>):</p>
<ul>
<li><p>A pattern variable introduced by a switch label is definitely
matched in all the statements of the switch labeled statement group.</p>
<p>It is a compile-time error if any pattern variable introduced by a
switch label is already in scope at the statements of the switch labeled
statement group.</p></li>
</ul>
</div>
<ul>
<li>A pattern variable introduced by a statement <em>S</em> contained in
a switch labeled statement group <del>(<a
href="#jls-14.11.1">14.11.1</a>)</del> is definitely matched at all the
statements following <em>S</em>, if any, in the switch labeled statement
group.</li>
</ul>
<h4 id="jls-6.3.2">6.3.2 Scope for Pattern Variables in Statements</h4>
<h5 id="jls-6.3.2.5">6.3.2.5 <code>for</code> Statements</h5>
<p>The following rules apply to a basic <code>for</code> statement (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-14.html#jls-14.14.1">14.14.1</a>):</p>
<ul>
<li><p>A pattern variable introduced by the condition expression when
true is definitely matched at both the incrementation part and the
contained statement.</p>
<p>It is a compile-time error if any pattern variable introduced by the
condition expression when true is already in scope at the incrementation
part of the contained statement.</p></li>
<li><p>A pattern variable is introduced by a basic <code>for</code>
statement iff (i) it is introduced by the condition expression when
false and (ii) the contained statement, <em>S</em>, does not contain a
reachable <code>break</code> statement whose break target contains
<em>S</em> (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-14.html#jls-14.15">14.15</a>).</p>
<p>It is a compile-time error if any pattern variable introduced by a
basic <code>for</code> statement is already in scope at the
<code>for</code> statement.</p></li>
</ul>
<p>An enhanced <code>for</code> statement (<a
href="#jls-14.14.2">14.14.2</a>) is defined by translation to a basic
<code>for</code> statement, so no special rules need to be provided for
it.</p>
<div class="inserted">
<blockquote>
<p>A property of the translation of an enhanced <code>for</code>
statement <code>for (p : e) S</code>, where <code>p</code> is a record
pattern, is that any pattern variable introduced by the pattern
<code>p</code> is definitely matched in the statement
<code>S</code>.</p>
</blockquote>
</div>
<h5 id="jls-6.3.2.6">6.3.2.6 <code>switch</code> Statements</h5>
<p>The following <del>rule applies</del> <strong>rules apply</strong> to
a <code>switch</code> statement <del>(<a
href="#jls-14.11">14.11</a>)</del> <strong>with a switch block
consisting of switch rules (<a
href="#jls-14.11.1">14.11.1</a>)</strong>:</p>
<div class="inserted">
<ul>
<li><p>A pattern variable introduced by a switch label is definitely
matched in the associated switch rule expression, switch rule block, or
switch rule <code>throw</code> statement.</p>
<p>It is a compile-time error if any pattern variable introduced by a
switch label is already in scope at the associated switch rule
expression, switch rule block, or switch rule <code>throw</code>
statement.</p></li>
</ul>
<p>The following rules apply to a switch expression with a switch block
consisting of switch labeled statement groups (<a
href="#jls-14.11.1">14.11.1</a>):</p>
<ul>
<li><p>A pattern variable introduced by a switch label is definitely
matched in all the statements of the switch labeled statement group.</p>
<p>It is a compile-time error if any pattern variable introduced by a
switch label is already in scope at the statements of the switch labeled
statement group.</p></li>
</ul>
</div>
<ul>
<li>A pattern variable introduced by a labeled statement <em>S</em>
contained in a switch block statement group <del>(<a
href="#jls-14.11.1">14.11.1</a>)</del> is definitely matched at all the
statements following <em>S</em>, if any, in the switch block statement
group.</li>
</ul>
<h4 id="jls-6.3.3"><strong>6.3.3 Scope for Pattern Variables in
Patterns</strong></h4>
<h5 id="jls-6.3.3.1"><strong>6.3.3.1 Record Patterns</strong></h5>
<div class="inserted">
<p>The following rule applies to a record pattern <em>p</em>:</p>
<ul>
<li><p>For each pattern <em>q</em> in the nested pattern list of
<em>p</em>, a pattern variable declared by <em>q</em> is definitely
matched in every record pattern component that comes after it within the
list.</p>
<p>It is a compile-time error if a pattern variable declared by
<em>q</em> is already in scope in a record pattern component that comes
after it within the list.</p>
<blockquote>
<p>This rule enforces a <em>linearity</em> constraint that pattern
variables can only be declared at most once in a single nested pattern
list. Specifying that two record components should have equal values can
not be encoded directly in the pattern but should be handled in
subsequent code:</p>
<pre><code>Object o = ...
if (o instanceof Point(int x, int y) &amp;&amp; (x == y)) { // Not the pattern Point(int x, int x)!
   System.out.println(&quot;Point on the diagonal&quot;);
}</code></pre>
</blockquote></li>
</ul>
</div>
<h4 id="jls-6.3.4"><strong>6.3.4 Scope for Pattern Variables in Switch
Labels</strong></h4>
<div class="inserted">
<p>Pattern variables can be introduced by <code>case</code> labels with
a <code>case</code> pattern, either by the pattern itself or by an
associated <code>when</code> expression, and are in scope for the
relevant parts of the associated <code>switch</code> expression (<a
href="#jls-6.3.1.6">6.3.1.6</a>) or <code>switch</code> statement (<a
href="#jls-6.3.2.6">6.3.2.6</a>).</p>
<p>The following rules apply to <code>case</code> labels:</p>
<ul>
<li><p>A pattern variable is introduced by a <code>case</code> label
with a <code>case</code> pattern <em>p</em> if it is declared by
<em>p</em>.</p></li>
<li><p>A pattern variable declared by the pattern of a guarded
<code>case</code> pattern is definitely matched in the associated
<code>when</code> expression.</p>
<p>It is a compile-time error if any pattern variable declared by the
pattern of a guarded <code>case</code> pattern is already in scope at
any associated <code>when</code> expression.</p></li>
<li><p>A pattern variable is introduced by a <code>case</code> label
with a guarded <code>case</code> pattern if it is introduced by the
associated <code>when</code> expression when true (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-6.html#jls-6.3.1">6.3.1</a>).</p></li>
</ul>
</div>
<h2 id="jls-13">Chapter 13: Binary Compatibility</h2>
<h3 id="jls-13.4">13.4 Evolution of Classes</h3>
<h4 id="jls-13.4.2">13.4.2 <code>sealed</code>, <code>non-sealed</code>,
and <code>final</code> Classes</h4>
<h5 id="jls-13.4.2.1">13.4.2.1 <code>sealed</code> Classes</h5>
<p>If a class that was freely extensible (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-8.html#jls-8.1.1.2">8.1.1.2</a>)
is changed to be declared <code>sealed</code>, then an
<code>IncompatibleClassChangeError</code> is thrown if a binary of a
pre-existing subclass of this class is loaded and is not a permitted
direct subclass of this class (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-8.html#jls-8.1.6">8.1.6</a>);
such a change is not recommended for widely distributed classes.</p>
<p>Changing a class that was declared <code>final</code> to be declared
<code>sealed</code> does not break compatibility with pre-existing
binaries.</p>
<p>Adding a class to the set of permitted direct subclasses of a
<code>sealed</code> class will not break compatibility with pre-existing
binaries.</p>
<div class="inserted">
<blockquote>
<p>Note that evolving a <code>sealed</code> class by adding a permitted
direct subclass is considered a binary compatible change because
pre-existing binaries that previously linked without error (e.g., a
class file that contains an exhaustive <code>switch</code> (<a
href="#jls-14.11.1">14.11.1</a>)) will continue to link without error. A
class file that contains an exhaustive <code>switch</code> will not fail
to link if the <code>sealed</code> class that it switches over is
expanded by the hierarchy's owner to have a new permitted direct
subclass. The JVM is not required to perform exhaustiveness checks when
linking a class file that contains an exhaustive
<code>switch</code>.</p>
</blockquote>
<blockquote>
<p>The execution of an exhaustive <code>switch</code> can fail with an
error (a <code>MatchException</code> is thrown) if it encounters an
instance of a permitted direct subclass that was not known at compile
time (<a href="#jls-14.11.3">14.11.3</a>, <a
href="#jls-15.28.2">15.28.2</a>). Strictly speaking, the error is not
flagging a binary incompatible change of the <code>sealed</code> class,
but more accurately a <em>migration incompatible</em> change of the
<code>sealed</code> class.</p>
</blockquote>
</div>
<p>If a class is removed from the set of permitted direct subclasses of
a <code>sealed</code> class, then an
<code>IncompatibleClassChangeError</code> is thrown if the pre-existing
binary of the removed class is loaded.</p>
<p>Deleting the <code>sealed</code> modifier from a class that does not
have a <code>sealed</code> direct superclass or a <code>sealed</code>
direct superinterface does not break compatibility with pre-existing
binaries.</p>
<blockquote>
<p>If a sealed class <em>C</em> did have a <code>sealed</code> direct
superclass or a <code>sealed</code> direct superinterface, then deleting
the <code>sealed</code> modifier would prevent <em>C</em> from being
recompiled, as every class with a <code>sealed</code> direct superclass
or a <code>sealed</code> direct superinterface must be either
<code>final</code>, <code>sealed</code>, or <code>non-sealed</code>.</p>
</blockquote>
<h4 id="jls-13.4.26">13.4.26 Evolution of Enum Classes</h4>
<p>Adding or reordering enum constants in an enum class will not break
compatibility with pre-existing binaries.</p>
<div class="inserted">
<blockquote>
<p>As with <code>sealed</code> classes (<a
href="#jls-13.4.2.1">13.4.2.1</a>), although adding an enum constant to
an enum class is considered a binary compatible change, it may cause the
execution of an exhaustive <code>switch</code> (<a
href="#jls-14.11.1">14.11.1</a>) to fail if the <code>switch</code>
encounters the new enum constant that was not known at compile time (<a
href="#jls-14.11.3">14.11.3</a>, <a
href="#jls-15.28.2">15.28.2</a>).</p>
</blockquote>
</div>
<p>Deleting an enum constant from an enum class will delete the
<code>public</code> field that corresponds to the enum constant (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-8.html#jls-8.9.3">8.9.3</a>).
The consequences are specified in <a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-13.html#jls-13.4.8">13.4.8</a>.
Such a change is not recommended for widely distributed enum
classes.</p>
<p>In all other respects, the binary compatibility rules for enum
classes are identical to those for normal classes.</p>
<h3 id="jls-13.5">13.5 Evolution of Interfaces</h3>
<h4 id="jls-13.5.2">13.5.2 <code>sealed</code> and
<code>non-sealed</code> Interfaces</h4>
<p>If an interface that was freely extensible (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-9.html#jls-9.1.1.4">9.1.1.4</a>)
is changed to be declared <code>sealed</code>, then an
<code>IncompatibleClassChangeError</code> is thrown if a binary of a
pre-existing subclass or subinterface of this interface is loaded and is
not a permitted direct subclass or subinterface of this interface (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-9.html#jls-9.1.4">9.1.4</a>);
such a change is not recommended for widely distributed classes.</p>
<p>Adding a class or interface to the set of permitted direct subclasses
or subinterfaces, respectively, of a <code>sealed</code> interface will
not break compatibility with pre-existing binaries.</p>
<div class="inserted">
<blockquote>
<p>As with <code>sealed</code> classes (<a
href="#jls-13.4.2.1">13.4.2.1</a>), whilst adding a permitted direct
subclass or subinterface of a <code>sealed</code> interface is
considered a binary compatible change, it may cause the execution of an
exhaustive <code>switch</code> (<a href="#jls-14.11.1">14.11.1</a>) to
fail with an error (a <code>MatchException</code> may be thrown) if the
<code>switch</code> encounters an instance of the new permitted direct
subclass or subinterface that was not known at compile time (<a
href="#jls-14.11.3">14.11.3</a>, <a
href="#jls-15.28.2">15.28.2</a>).</p>
</blockquote>
</div>
<p>If a class or interface is removed from the set of permitted direct
subclasses or subinterfaces of a <code>sealed</code> interface, then an
<code>IncompatibleClassChangeError</code> is thrown if the pre-existing
binary of the removed class or interface is loaded.</p>
<p>Changing an interface that was declared <code>sealed</code> to be
declared <code>non-sealed</code> does not break compatibility with
pre-existing binaries.</p>
<blockquote>
<p>A <code>non-sealed</code> interface <em>I</em> must have a
<code>sealed</code> direct superinterface. Deleting the
<code>non-sealed</code> modifier would prevent <em>I</em> from being
recompiled, as every interface with a <code>sealed</code> direct
superinterface must be <code>sealed</code> or
<code>non-sealed</code>.</p>
</blockquote>
<p>Deleting the <code>sealed</code> modifier from an interface that does
not have a <code>sealed</code> direct superinterface does not break
compatibility with pre-existing binaries.</p>
<blockquote>
<p>If a sealed interface <em>I</em> did have a <code>sealed</code>
direct superinterface, then deleting the <code>sealed</code> modifier
would prevent <em>I</em> from being recompiled, as every interface with
a <code>sealed</code> direct superinterface must be <code>sealed</code>
or <code>non-sealed</code>.</p>
</blockquote>
<h2 id="jls-14">Chapter 14: Blocks, Statements, and Patterns</h2>
<h3 id="jls-14.11">14.11 The <code>switch</code> Statement</h3>
<p>The <code>switch</code> statement transfers control to one of several
statements or expressions, depending on the value of an expression.</p>
<dl>
<dt><em>SwitchStatement:</em></dt>
<dd>
<code>switch</code> <code>(</code> <em>Expression</em> <code>)</code>
<em>SwitchBlock</em>
</dd>
</dl>
<p>The <em>Expression</em> is called the <em>selector expression</em>.
<del>The type of the selector expression must be <code>char</code>,
<code>byte</code>, <code>short</code>, <code>int</code>,
<code>Character</code>, <code>Byte</code>, <code>Short</code>,
<code>Integer</code>, <code>String</code>, or an enum type (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-8.html#jls-8.9">8.9</a>),
or a compile-time error occurs.</del></p>
<div class="editorial">
<p>These restrictions on the type of the selector expression are now
included in the notion of a switch block being <em>compatible</em> with
a selector expression, defined in the following section.</p>
</div>
<h4 id="jls-14.11.1">14.11.1 Switch Blocks</h4>
<p>The body of both a <code>switch</code> statement and a
<code>switch</code> expression (<a href="#jls-15.28">15.28</a>) is
called a <em>switch block</em>. This subsection presents general rules
which apply to all switch blocks, whether they appear in
<code>switch</code> statements or <code>switch</code> expressions. Other
subsections present additional rules which apply either to switch blocks
in <code>switch</code> statements (<a href="#jls-14.11.2">14.11.2</a>)
or to switch blocks in <code>switch</code> expressions (<a
href="#jls-15.28.1">15.28.1</a>).</p>
<dl>
<dt><em>SwitchBlock:</em></dt>
<dd>
<code>{</code> <em>SwitchRule</em> {<em>SwitchRule</em>} <code>}</code>
</dd>
<dd>
<code>{</code> {<em>SwitchBlockStatementGroup</em>}
{<em>SwitchLabel</em> <code>:</code>} <code>}</code>
</dd>
<dt><em>SwitchRule:</em></dt>
<dd>
<em>SwitchLabel</em> <code>-&gt;</code> <em>Expression</em>
<code>;</code>
</dd>
<dd>
<em>SwitchLabel</em> <code>-&gt;</code> <em>Block</em>
</dd>
<dd>
<em>SwitchLabel</em> <code>-&gt;</code> <em>ThrowStatement</em>
</dd>
<dt><em>SwitchBlockStatementGroup:</em></dt>
<dd>
<em>SwitchLabel</em> <code>:</code> { <em>SwitchLabel</em>
<code>:</code>} <em>BlockStatements</em>
</dd>
<dt><em>SwitchLabel:</em></dt>
<dd>
<code>case</code> <em>CaseConstant</em> {<code>,</code>
<em>CaseConstant</em>}
</dd>
<dd>
<strong><code>case null</code> [<code>, default</code>]</strong>
</dd>
<dd>
<strong><code>case</code> <em>CasePattern</em></strong>
</dd>
<dd>
<code>default</code>
</dd>
<dt><em>CaseConstant:</em></dt>
<dd>
<em>ConditionalExpression</em>
</dd>
</dl>
<div class="inserted">
<dl>
<dt><em>CasePattern</em>:</dt>
<dd>
<em>Pattern</em> [ <em>Guard</em> ]
</dd>
<dt><em>Guard</em>:</dt>
<dd>
<code>when</code> <em>Expression</em>
</dd>
</dl>
</div>
<p>A switch block can consist of either:</p>
<ul>
<li><p><em>Switch rules</em>, which use <code>-&gt;</code> to introduce
either a <em>switch rule expression</em>, a <em>switch rule block</em>,
or a <em>switch rule <code>throw</code> statement</em>; or</p></li>
<li><p><em>Switch labeled statement groups</em>, which use
<code>:</code> to introduce <em>switch labeled block
statements</em>.</p></li>
</ul>
<p>Every switch rule and switch labeled statement group starts with a
<em>switch label</em>, which is either a <code>case</code> label or a
<code>default</code> label. Multiple switch labels are permitted for a
switch labeled statement group.</p>
<div class="deleted">
<p>A <code>case</code> label has one or more <code>case</code>
constants. Every <code>case</code> constant must be either a constant
expression (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-15.html#jls-15.29">15.29</a>)
or the name of an enum constant (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-8.html#jls-8.9.1">8.9.1</a>),
or a compile-time error occurs.</p>
<p>Switch labels and their <code>case</code> constants are said to be
<em>associated</em> with the switch block. No two of the
<code>case</code> constants associated with a switch block may have the
same value, or a compile-time error occurs.</p>
</div>
<div class="inserted">
<p>A <code>case</code> label consists of either a list of
<code>case</code> constants or a single <code>case</code> pattern.</p>
<p>Every <code>case</code> constant must be either (1) the
<code>null</code> literal, (2) a constant expression (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-15.html#jls-15.29">15.29</a>),
or (3) the name of an enum constant (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-8.html#jls-8.9.1">8.9.1</a>);
otherwise a compile-time error occurs. A single <code>null</code> case
constant may also be paired with the <code>default</code> keyword.</p>
<!--
Syntactic: A `case` label with a `case` pattern that has a `when` expression
Semantic:  A `case` label with an unguarded `case` pattern
-->
<p>A <code>case</code> pattern may have an optional <code>when</code>
expression, which represents a further test on values that match the
pattern. A <code>case</code> pattern is said to be <em>unguarded</em> if
either (i) it has no <code>when</code> expression, or (ii) it has a
<code>when</code> expression that is a constant expression (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-15.html#jls-15.29">15.29</a>)
with value <code>true</code>; and <em>guarded</em> otherwise.</p>
<p>Switch labels and their <code>case</code> constants and
<code>case</code> patterns are said to be <em>associated</em> with the
switch block.</p>
<p>For a given switch block both of the following must be true,
otherwise a compile-time error occurs:</p>
<ul>
<li>No two of the <code>case</code> constants associated with a switch
block may have the same value.</li>
</ul>
<!-- The following rule is covered by the new dominance rules:

-   A switch block may not have both an associated `default` label and a `case`
    label with a `default`.
-->
<ul>
<li>No more than one <code>default</code> label may be associated with a
switch block.</li>
</ul>
<!--
The following check is not needed. For this to apply, there would have to be more
 than one null case constant which is ruled out by the first rule!

-   No more than one of the `case` labels associated with a switch block may
    have a `default`.
-->
<p>Any <code>when</code> expression associated with a switch block must
have type <code>boolean</code> or <code>Boolean</code>. Any variable
that is used but not declared in a <code>when</code> expression must be
either final or effectively final (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-4.html#jls-4.12.4">4.12.4</a>).
It is a compile-time error if a <code>when</code> expression is a
constant expression (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-15.html#jls-15.29">15.29</a>)
with the value <code>false</code>.</p>
</div>
<div class="deleted">
<p>The switch block of a <code>switch</code> statement or a
<code>switch</code> expression is <em>compatible</em> with the type of
the selector expression, <em>T</em>, if both of the following are
true:</p>
<ul>
<li><p>If <em>T</em> is not an enum type, then every <code>case</code>
constant associated with the switch block is assignment compatible with
<em>T</em> (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-5.html#jls-5.2">5.2</a>).</p></li>
<li><p>If <em>T</em> is an enum type, then every <code>case</code>
constant associated with the switch block is an enum constant of type
<em>T</em>.</p></li>
</ul>
</div>
<div class="inserted">
<p>The switch block of a <code>switch</code> statement or a
<code>switch</code> expression is <em>switch compatible</em> with the
type of the selector expression, <em>T</em>, if all of the following are
true:</p>
<ul>
<li><p>A <code>null</code> literal is associated with the switch block
only if <em>T</em> is a reference type.</p></li>
<li><p>A constant expression <em>c</em> is associated with the switch
block only if <em>T</em> is one of <code>char</code>, <code>byte</code>,
<code>short</code>, <code>int</code>, <code>Character</code>,
<code>Byte</code>, <code>Short</code>, <code>Integer</code>, or
<code>String</code>; and only if <em>c</em> is assignment compatible
with <em>T</em> (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-5.html#jls-5.2">5.2</a>).</p></li>
<li><p>An enum constant <em>e</em> is associated with the switch block
only if <em>T</em> is the enum type of <em>E</em>.</p></li>
<li><p>A pattern <em>p</em> is associated with the switch block only if
<em>p</em> is applicable at type <em>T</em> (<a
href="#jls-14.30.3">14.30.3</a>).</p></li>
</ul>
<blockquote>
<p>No <code>case</code> label supports a selector expression of type
<code>boolean</code>, <code>long</code>, <code>float</code>, or
<code>double</code>. Switch blocks are not designed to work with these
types.</p>
</blockquote>
</div>
<p>The switch block of a <code>switch</code> statement or a
<code>switch</code> expression must be <strong>switch</strong>
compatible with the type of the selector expression, or a compile-time
error occurs.</p>
<div class="inserted">
<p>A switch label is said to <em>dominate</em> another switch label if
the former applies to every value that the latter applies to. It is a
compile-time error if a switch label in a switch block dominates any
switch label that follows it. The rules for determining dominance are as
follows:</p>
<ul>
<li><p>A <code>case</code> label with an unguarded <code>case</code>
pattern <em>p</em> dominates another <code>case</code> label with a
<code>case</code> pattern <em>q</em> if <em>p</em> dominates <em>q</em>
(<a href="#jls-14.30.3">14.30.3</a>).</p>
<blockquote>
<p>The definition of one pattern dominating another pattern (<a
href="#jls-14.30.3">14.30.3</a>) is based on types. For example, the
following results in a compile-time error:</p>
<pre><code>Object obj = ...
switch (obj) {
    case Object o -&gt;
        System.out.println(&quot;An object&quot;);
    case String s   -&gt;                 // Error - dominated case label
        System.out.println(&quot;A string&quot;);
}</code></pre>
<p>More precisely, pattern dominance is defined in terms of the
<em>erasure</em> of types. For example, the type pattern
<code>ArrayList&lt;? extends Number&gt; al</code> dominates the type
pattern <code>ArrayList&lt;Number&gt; aln</code> and vice versa. The
following results in a compile-time error:</p>
<pre><code>List&lt;Number&gt; l = ...;
switch (l) {
    case ArrayList&lt;Number&gt; al -&gt;
        System.out.println(&quot;An ArrayList of Number&quot;);
    case ArrayList&lt;? extends Number&gt; aln -&gt; // Error - dominated case label
        System.out.println(&quot;An ArrayList of Number&quot;);
    default -&gt;
        System.out.println(&quot;A List&quot;);
}</code></pre>
<p>A <code>case</code> label with a guarded <code>case</code> pattern is
dominated by a <code>case</code> label with the same pattern but without
the guard. For example, the following results in a compile-time
error:</p>
<pre><code>String str = ...;
switch (str) {
    case String s -&gt;
        System.out.println(&quot;A string&quot;);
    case String s when s.length() == 2 -&gt;  // Error - dominated case label
        System.out.println(&quot;Two character string&quot;);
    ...
}</code></pre>
<p>On the other hand, a <code>case</code> label with a guarded
<code>case</code> pattern <em>p</em> is not considered to dominate a
<code>case</code> label with an unguarded <code>case</code> pattern
<em>p</em>. This allows the following common pattern programming
style:</p>
<pre><code>Integer j = ...;
switch (j) {
    case Integer i when i &lt;= 0 -&gt;
        System.out.println(&quot;Less than or equal to zero&quot;);
    case Integer i -&gt;
        System.out.println(&quot;An integer&quot;);
}</code></pre>
<p>The only exception is where the <code>when</code> expression is a
constant expression that has the value <code>true</code>, for
example:</p>
<pre><code>Integer j = ...;
switch (j) {
    case Integer i when true -&gt;            // Allowed but why write this?
        System.out.println(&quot;An integer&quot;);
    case Integer i -&gt;                     // Error - dominated case label
        System.out.println(&quot;An integer&quot;);
}</code></pre>
</blockquote></li>
</ul>
<!-- The following rule was removed in JDK 19 preview. Now `null` labels are
the only things that match when a selector expression evaluates to null.

-   A switch label that has a pattern case label element *p* that is total for
    the type of the selector expression of the enclosing `switch` statement or
    `switch` expression dominates a switch label that has a `null` case label
    element.

-->
<ul>
<li><p>A <code>case</code> label with a <code>case</code> pattern
<em>p</em> (guarded or unguarded) dominates another <code>case</code>
label with a <code>case</code> constant <em>c</em> if one of the
following is true:</p>
<ul>
<li><p><em>p</em> is a type pattern (possibly nested within parentheses)
that declares a pattern variable of type <em>T</em>, <em>c</em> is a
constant expression of a primitive type <em>S</em>, and the wrapper
class (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-5.html#jls-5.1.7">5.1.7</a>)
of <em>S</em> is a subtype of the erasure of <em>T</em>.</p></li>
<li><p><em>p</em> is a type pattern (possibly nested within parentheses)
that declares a pattern variable of type <em>T</em>, <em>c</em> is a
constant expression or an enum constant of reference type <em>S</em>,
and <em>S</em> is a subtype of the erasure of <em>T</em>.</p></li>
</ul>
<blockquote>
<p>For example, a label with an <code>Integer</code> type pattern
dominates a label with an <code>int</code> literal:</p>
<pre><code>Integer j = ...;
switch (j) {
    case Integer i -&gt;
        System.out.println(&quot;An integer&quot;);
    case 42 -&gt;                              // Error - dominated!
        System.out.println(&quot;42!&quot;);
}</code></pre>
<p>Analysis of <code>when</code> expressions—undecidable in general—is
not attempted. For example, the following results in a compile-time
error, even though the first switch label does not match if the value of
the selector expression is <code>42</code>:</p>
<pre><code>Integer j = ...;
switch (j) {
    case Integer i when i != 42 -&gt;
        System.out.println(&quot;An integer that isn&#39;t 42&quot;);
    case 42 -&gt;                                  // Error - dominated!
        System.out.println(&quot;42!&quot;);
}</code></pre>
<p>Any <code>case</code> labels with <code>case</code> constants should
appear before those with <code>case</code> patterns; for example:</p>
<pre><code>Integer j = ...;
switch (j) {
    case 42 -&gt;
        System.out.println(&quot;42&quot;);
    case Integer i when i &lt; 50 -&gt;
        System.out.println(&quot;An integer less than 50&quot;);
    case Integer i  -&gt;
        System.out.println(&quot;An integer&quot;);
}</code></pre>
</blockquote></li>
</ul>
<!--
The following rules are new for the JDK 20 preview. We force default labels to come last
if it is a new switch block.
-->
<ul>
<li><p>A <code>default</code> label dominates a <code>case</code> label
with a <code>case</code> pattern, and it also dominates a
<code>case</code> label with a <code>null</code> <code>case</code>
constant.</p>
<blockquote>
<p>If used, a <code>default</code> label should come last in a
<code>switch</code> block.</p>
<p>For historical reasons, a <code>default</code> label may appear
<em>before</em> <code>case</code> labels with non-<code>null</code>
<code>case</code> constants.</p>
<pre><code>int i = ...;
switch(i) {
    default -&gt;
        System.out.println(&quot;Some other integer&quot;);
    case 42 -&gt; // allowed
        System.out.println(&quot;42&quot;);
}</code></pre>
<p>This style is discouraged in new code.</p>
</blockquote></li>
<li><p>A <code>case null, default</code> label dominates all other
switch labels.</p>
<blockquote>
<p>If used, a <code>case null, default</code> label always comes last in
a <code>switch</code> block.</p>
</blockquote></li>
</ul>
<!--
The following rule is new for JDK 20 preview; it was previously a separate condition,
but now has been folded into the dominance relation, given the rule above has
also been added.
-->
<ul>
<li><p>A <code>case</code> label with an unguarded <code>case</code>
pattern <em>p</em> where <em>p</em> is unconditional at the type of the
selector expression (<a href="#jls-14.30.3">14.30.3</a>) dominates a
<code>default</code> label and a <code>case null, default</code>
label.</p>
<blockquote>
<p>A <code>case</code> label with a <code>case</code> pattern that is
unconditional at the type of the selector expression will, as the name
suggests, match every value and so behaves like a <code>default</code>
label. A switch block can not have more than one switch label that acts
like a <code>default</code>.</p>
</blockquote></li>
</ul>
<p>It is a compile-time error if, in a switch block that consists of
switch labeled statement groups, a statement is labeled with a
<code>case</code> pattern that declares one or more pattern variables,
and either:</p>
<ul>
<li><p>An immediately preceding statement in the switch block can
complete normally (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-14.html#jls-14.22">14.22</a>),
or</p></li>
<li><p>The statement is labeled with more than one switch
label.</p></li>
</ul>
<blockquote>
<p>The first condition prevents a statement group from "falling through"
to another statement group without initializing pattern variables. For
example, were a statement labeled by <code>case Integer i</code>
reachable from the preceding statement group, the pattern variable
<code>i</code> would not have been initialized:</p>
<pre><code>Object o = &quot;Hello&quot;;
switch (o) {
    case String s:
        System.out.println(&quot;String: &quot; + s );  // No break!
    case Integer i:
        System.out.println(i + 1);            // Error! Can be reached
                                              // without matching the
                                              // pattern `Integer i`
    default:
}</code></pre>
<p>Switch blocks consisting of switch label statement groups allow
multiple labels to apply to a statement group. The second condition
prevents a statement group from being executed based on one label
without initializing the pattern variables of another label. For
example:</p>
<pre><code>Object o = &quot;Hello World&quot;;
switch (o) {
    case String s:
    case Integer i:
        System.out.println(i + 1);  // Error! Can be reached
                                    // without matching the
                                    // pattern `Integer i`
    default:
}

Object obj = null;
switch (obj) {
    case null:
    case String s:
        System.out.println(s);      // Error! Can be reached
                                    // without matching the
                                    // pattern `String s`
    default:
}</code></pre>
<p>Both of these conditions apply only when the <code>case</code>
pattern declares pattern variables. The following examples, in contrast,
are unproblematic:</p>
<pre><code>record R() {}
record S() {}

Object o = &quot;Hello World&quot;;
switch (o) {
    case String s:
        System.out.println(s);        // No break!
    case R():
        System.out.println(&quot;It&#39;s either an R or a string&quot;);
        break;
    default:
}

Object ob = new R();
switch (ob) {
    case R():
    case S():                         // Multiple case labels!
        System.out.println(&quot;Either R or an S&quot;);
        break;
    default:
}

Object obj = null;
switch (obj) {
    case null:
    case R():                         // Multiple case labels!
        System.out.println(&quot;Either null or an R&quot;);
        break;
    default:
}</code></pre>
</blockquote>
</div>
<h5 id="jls-14.11.1.1"><strong>14.11.1.1 Exhaustive Switch
Blocks</strong></h5>
<div class="inserted">
<p>The switch block of a <code>switch</code> expression or
<code>switch</code> statement is <em>exhaustive</em> for a selector
expression of type <em>T</em> if either (i) there is a
<code>default</code> label associated with the switch block, or (ii)
there is a <code>case</code> label with a <code>default</code>
associated with the switch block, or (iii) the set containing all the
<code>case</code> constants and unguarded <code>case</code> patterns
(collectively known as <code>case</code> elements) associated with the
switch block is non-empty and exhausts <em>T</em>, which is specified as
follows:</p>
<ul>
<li><p>A set of <code>case</code> elements exhausts an enum class type
<em>E</em> if it contains all of the enum constants of <em>E</em>.</p>
<blockquote>
<p>Note this means that a <code>default</code> label is permitted, but
not required in the case where all the enum constants appear as
<code>case</code> constants. For example:</p>
<pre><code>enum E { F, G, H }

static int testEnumExhaustive(E e) {
    return switch(e) {
        case F -&gt; 0;
        case G -&gt; 1;
        case H -&gt; 2;    // No default required!
    };
}</code></pre>
</blockquote></li>
<li><p>A set of <code>case</code> elements exhausts a type <em>T</em> if
it exhausts a type <em>S</em> and <em>S</em> is downcast convertible to
<em>T</em> (<a href="#jls-5.5">5.5</a>).</p>
<blockquote>
<p>If a set of <code>case</code> elements exhausts a type then it will
exhaust a range of other types, in particular those types that are
downcast convertible. For example, if a set exhausts the type
<code>Object</code> then it clearly also exhausts the type
<code>String</code>. However, if a set exhausts the type
<code>List&lt;Object&gt;</code> then it does not exhaust the type
<code>List&lt;String&gt;</code>. In contrast, a set that exhausts the
type <code>List&lt;? extends Object&gt;</code> also exhausts the type
<code>List&lt;String&gt;</code>.</p>
</blockquote></li>
<li><p>A set of <code>case</code> elements exhausts a type <em>T</em> if
it contains a type pattern of type <em>T</em> (<a
href="#jls-14.30.3">14.30.3</a>).</p></li>
<li><p>A set of <code>case</code> elements exhausts a type <em>T</em>
that names an <code>abstract</code> and <code>sealed</code> class or
interface <em>C</em>, if for every permitted direct subclass or
subinterface <em>D</em> of <em>C</em>, one of the following two
conditions holds:</p>
<ol type="1">
<li><p><em>D</em> is not a generic class or interface, <em>T</em> is
downcast convertible to <em>D</em>, and the set of <code>case</code>
elements exhausts the type <em>D</em>.</p></li>
<li><p><em>D</em> is a generic class or interface, and either (i) there
is no parameterized type <em>S</em> that names <em>D</em> that is
downcast convertible to <em>T</em>, or (ii) the set of case elements
exhausts a type <em>S</em> that names <em>D</em> where <em>S</em> is
downcast convertible to <em>T</em>.</p></li>
</ol>
<blockquote>
<p>Note this means that a <code>default</code> label is permitted, but
not required in the case where the switch block exhausts all the
permitted direct subclasses and subinterfaces of an
<code>abstract</code> and <code>sealed</code> class or interface. For
example:</p>
<pre><code>sealed interface I permits A, B, C {}
final class A   implements I {}
final class B   implements I {}
record C(int j) implements I {}  // Implicitly final

static int testExhaustive1(I i) {
    return switch(i) {
        case A a -&gt; 0;
        case B b -&gt; 1;
        case C c -&gt; 2;           // No default required!
    };
}</code></pre>
<p>As the switch block contains switch labels supporting patterns that
match against values of type <code>A</code>, <code>B</code> and
<code>C</code>, and no other instances of type <code>I</code> are
permitted, this switch block is exhaustive.</p>
<p>The fact that a permitted direct subclass or subinterface may only
extend a particular parameterization of a generic <code>sealed</code>
superclass or superinterface means that it may not always need to be
considered when determining whether a switch block is exhaustive. For
example:</p>
<pre><code>sealed interface J&lt;X&gt; permits D, E {}
final class D&lt;Y&gt; implements J&lt;String&gt; {}
final class E&lt;X&gt; implements J&lt;X&gt; {}

static int testExhaustive2(J&lt;Integer&gt; ji) {
    return switch(ji) {          // Exhaustive!
        case E&lt;Integer&gt; e -&gt; 42;
    };
}</code></pre>
<p>As the selector expression has type <code>J&lt;Integer&gt;</code> the
permitted direct subclass <code>D</code> need not be considered as there
is no possibility that the value of <code>ji</code> can be an instance
of <code>D</code>.</p>
</blockquote></li>
<li><p>A set of <code>case</code> elements, <em>P</em>, exhausts a type
<em>T</em> that names a record class <em>R</em> if (i) <em>Q</em> is a
non-empty subset of <em>P</em> containing only record patterns with the
type <em>T</em>, and (ii) either the record class <em>R</em> has zero
record components or <em>Q</em> is exhaustive from component <em>c</em>
at type <em>U</em>, where <em>c</em> is the first component in the
record component list of <em>R</em>, and <em>U</em> is the type of the
corresponding component field in <em>T</em> (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-8.html#jls-8.10.3">8.10.3</a>).</p>
<p>Given a record type <em>T</em> that names a record class <em>R</em>,
a set of record patterns <em>P</em> is <em>exhaustive from a record
component <em>c</em> at a type <em>U</em></em> if</p>
<ol type="i">
<li>the set of patterns containing the component patterns corresponding
to <em>c</em> from every record pattern in <em>P</em> exhausts the type
<em>U</em>, and (ii) if <em>c</em> is not the final component of the
record component list of the record class <em>R</em> then one of the
following is true:</li>
</ol>
<ol type="1">
<li><p>The set <em>Q</em> is exhaustive from component <em>d</em> at
type <em>V</em>, where <em>d</em> is the component following <em>c</em>,
<em>V</em> is the type of corresponding component field in <em>T</em>,
and <em>Q</em> is the set of patterns containing every record pattern in
<em>P</em> whose component pattern corresponding to <em>c</em> is
exhaustive for <em>U</em>.</p></li>
<li><p>The type <em>U</em> is a class or interface type that names an
<code>abstract</code> and <code>sealed</code> class or interface
<em>D</em>, and for every permitted direct subclass or subinterface
<em>E</em> of <em>D</em>, one of the following two conditions holds:</p>
<ol type="i">
<li><p><em>E</em> is not a generic class or interface, <em>U</em> is
downcast convertible to <em>E</em>, and <em>P</em> is exhaustive from
component <em>c</em> at type <em>E</em>.</p></li>
<li><p><em>E</em> is a generic class or interface, and either (i) there
is no parameterized type <em>V</em> that names <em>E</em> that is
downcast convertible to <em>U</em>, or (ii) <em>P</em> is exhaustive
from component <em>c</em> at a type <em>V</em> that names <em>E</em>,
where <em>V</em> is downcast convertible to <em>U</em>.</p></li>
</ol></li>
</ol></li>
</ul>
<p>A <code>switch</code> statement or expression is <em>exhaustive</em>
if its switch block exhausts the type of the selector expression.</p>
</div>
<h5 id="jls-14.11.1.2"><strong>14.11.1.2 Executable Switch Blocks and
Determining which Switch Label Applies at Run-Time</strong></h5>
<div class="inserted">
<p>As the meaning of some patterns is determined by the type of the
expression that is being matched against, patterns must be resolved
before pattern matching can be performed (<a
href="#jls-14.30.2">14.30.2</a>). Consequently, any <code>case</code>
patterns associated with a switch block of a <code>switch</code>
expression or <code>switch</code> statement must also be resolved.</p>
<p>An <em>executable</em> <code>switch</code> expression or
<code>switch</code> statement is one where every <code>case</code>
pattern associated with the switch block has been resolved with respect
to the type of the selector expression, <em>T</em>, as follows:</p>
<ul>
<li>A <code>case</code> label with a <code>case</code> pattern
<em>p</em> is resolved to a <code>case</code> label with a
<code>case</code> pattern <em>q</em>, where <em>q</em> is the result of
resolving pattern <em>p</em> at type <em>T</em> (<a
href="#jls-14.30.2">14.30.2</a>). If <em>p</em> is guarded, then
<em>q</em> is guarded with the same <code>when</code> expression.</li>
</ul>
</div>
<div class="deleted">
<p>Both the execution of a <code>switch</code> statement (<a
href="#jls-14.11.3">14.11.3</a>) and the evaluation of a
<code>switch</code> expression (<a href="#jls-15.28.2">15.28.2</a>) need
to determine if a switch label <em>matches</em> the value of the
selector expression. To determine whether a switch label in a switch
block matches a given value, the value is compared with the
<code>case</code> constants associated with the switch block. Then:</p>
<ul>
<li><p>If one of the <code>case</code> constants is equal to the value,
then we say that the <code>case</code> label which contains the
<code>case</code> constant <em>matches</em>.</p>
<p>Equality is defined in terms of the <code>==</code> operator (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-15.html#jls-15.21">15.21</a>)
unless the value is a <code>String</code>, in which case equality is
defined in terms of the <code>equals</code> method of class
<code>String</code>.</p></li>
<li><p>If no <code>case</code> label matches but there is a
<code>default</code> label, then we say that the <code>default</code>
label <em>matches</em>.</p></li>
</ul>
</div>
<div class="inserted">
<p>Both the execution of an executable <code>switch</code> statement (<a
href="#jls-14.11.3">14.11.3</a>) and the evaluation of an executable
<code>switch</code> expression (<a href="#jls-15.28.2">15.28.2</a>) need
to determine if a switch label associated with the switch block
<em>applies</em> to the value of the selector expression, as
follows:</p>
<ol type="1">
<li><p>If the value is the null reference, then a <code>case</code>
label with a <code>null</code> <code>case</code> constant
applies.</p></li>
<li><p>If the value is not the null reference, then we determine the
first (if any) <code>case</code> label in the switch block that applies
to the value as follows:</p>
<ul>
<li><p>A <code>case</code> label with a non-null <code>case</code>
constant <em>c</em> applies to a value of type <code>Character</code>,
<code>Byte</code>, <code>Short</code>, or <code>Integer</code>, if the
value is first subjected to unboxing conversion (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-5.html#jls-5.1.8">5.1.8</a>)
and the constant <em>c</em> is equal to the unboxed value.</p>
<blockquote>
<p>Any unboxing conversion must complete normally as the value being
unboxed is guaranteed not to be the null reference.</p>
</blockquote>
<p>Equality is defined in terms of the <code>==</code> operator (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-15.html#jls-15.21">15.21</a>).</p></li>
<li><p>A <code>case</code> label with a non-null <code>case</code>
constant <em>c</em> applies to a value that is not of type
<code>Character</code>, <code>Byte</code>, <code>Short</code>, or
<code>Integer</code>, if the constant <em>c</em> is equal to the
value.</p>
<p>Equality is defined in terms of the <code>==</code> operator unless
the value is a <code>String</code>, in which case equality is defined in
terms of the <code>equals</code> method of class
<code>String</code>.</p></li>
<li><p>Determining that a <code>case</code> label with a
<code>case</code> pattern <em>p</em> applies to a value proceeds first
by checking if the value matches the pattern <em>p</em> (<a
href="#jls-14.30.2">14.30.2</a>).</p>
<p>If pattern matching completes abruptly then the process of
determining which switch label applies completes abruptly for the same
reason.</p>
<p>If pattern matching succeeds and the <code>case</code> pattern is
unguarded then this <code>case</code> label applies.</p>
<p>If pattern matching succeeds and the <code>case</code> pattern is
guarded, then the <code>when</code> expression is evaluated. If the
result is of type <code>Boolean</code>, it is subjected to unboxing
conversion (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-5.html#jls-5.1.8">5.1.8</a>).</p>
<p>If evaluation of the <code>when</code> expression or the subsequent
unboxing conversion (if any) completes abruptly for some reason, the
process of determining which switch label applies completes abruptly for
the same reason.</p>
<p>Otherwise, if the resulting value is <code>true</code> then the
<code>case</code> label applies.</p></li>
<li><p>A <code>case null, default</code> label applies to every
value</p></li>
</ul></li>
<li><p>If the value is not the null reference, and no <code>case</code>
label applies according to the rules of step 2, then if a
<code>default</code> label is associated with the switch block, that
label applies.</p></li>
</ol>
</div>
<blockquote>
<p>A <strong>single</strong> <code>case</code> label can contain several
<code>case</code> constants. The label <del>matches</del>
<strong>applies to</strong> the value of the selector expression if any
one of its constants <del>matches</del> <strong>is equal to</strong> the
value of the selector expression. For example, in the following code,
the <code>case</code> label matches if the enum variable
<code>day</code> is either one of the enum constants shown:</p>
<pre><code>switch (day) {
    ...
    case SATURDAY, SUNDAY :
        System.out.println(&quot;It&#39;s the weekend!&quot;);
        break;
    ...
}</code></pre>
<p>If a switch label that supports a pattern applies, then this is
because the process of pattern matching the value against the pattern
has succeeded (<a href="#jls-14.30.2">14.30.2</a>). If a value
successfully matches a pattern then the process of pattern matching
initializes any pattern variables declared by the pattern.</p>
</blockquote>
<div class="inserted">
<blockquote>
<p>For historical reasons, a <code>default</code> label is only
considered after all <code>case</code> labels have failed to match, even
if some of those labels appear after the <code>default</code> label.
However, subsequent labels may only make use of non-<code>null</code>
case constants (<a href="#jls-14.11.1">14.11.1</a>), and as a matter of
style, programmers are encouraged to place their <code>default</code>
labels last.</p>
</blockquote>
</div>
<div class="deleted">
<blockquote>
<p><code>null</code> cannot be used as a <code>case</code> constant
because it is not a constant expression. Even if <code>case</code>
<code>null</code> was allowed, it would be undesirable because the code
in that <code>case</code> can never be executed. Namely, if the selector
expression is of a reference type (that is, <code>String</code> or a
boxed primitive type or an enum type), then an exception will occur if
the selector expression evaluates to <code>null</code> at run time. In
the judgment of the designers of the Java programming language,
propagating the exception is a better outcome than either having no
<code>case</code> label match, or having the <code>default</code> label
match.</p>
</blockquote>
</div>
<blockquote>
<p>In C and C++ the body of a <code>switch</code> statement can be a
statement and statements with <code>case</code> labels do not have to be
immediately contained by that statement. Consider the simple loop:</p>
<pre><code>for (i = 0; i &lt; n; ++i) foo();</code></pre>
<p>where <code>n</code> is known to be positive. A trick known as
<em>Duff's device</em> can be used in C or C++ to unroll the loop, but
this is not valid code in the Java programming language:</p>
<pre><code>int q = (n+7)/8;
switch (n%8) {
    case 0: do { foo();    // Great C hack, Tom,
    case 7:      foo();    // but it&#39;s not valid here.
    case 6:      foo();
    case 5:      foo();
    case 4:      foo();
    case 3:      foo();
    case 2:      foo();
    case 1:      foo();
            } while (--q &gt; 0);
}</code></pre>
<p>Fortunately, this trick does not seem to be widely known or used.
Moreover, it is less needed nowadays; this sort of code transformation
is properly in the province of state-of-the-art optimizing
compilers.</p>
</blockquote>
<h4 id="jls-14.11.2">14.11.2 The Switch Block of a <code>switch</code>
Statement</h4>
<p>In addition to the general rules for switch blocks (<a
href="#jls-14.11.1">14.11.1</a>), there are further rules for switch
blocks in <code>switch</code> statements.</p>
<!--
The notion of an enhanced switch statement is not just the simple "check for a pattern or null label" in the switch block. That is because it is permissible to write an empty switch block.

For example:

interface I {}
enum E implements I {}
E e = ...
switch (e){}

This is acceptable for backwards compatibility reasons.
But we want to flag this as an error:

I i = ...
switch (i){}

The only difference between this and the former as that the former is switching over one of the old approved types.

-->
<p><strong>An <em>enhanced</em> <code>switch</code> statement is one
where either (i) the type of the selector expression is not
<code>char</code>, <code>byte</code>, <code>short</code>,
<code>int</code>, <code>Character</code>, <code>Byte</code>,
<code>Short</code>, <code>Integer</code>, <code>String</code>, or an
enum type, or (ii) there is a <code>case</code> pattern or
<code>null</code> <code>case</code> constant associated with the switch
block.</strong></p>
<p><del>Namely, all</del> <strong>All</strong> of the following must be
true for the switch block of a <code>switch</code> statement, or a
compile-time error occurs:</p>
<ul>
<li><p><del>No more than one <code>default</code> label is associated
with the <code>switch</code> block.</del></p></li>
<li><p>Every switch rule expression in the switch block is a statement
expression (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-14.html#jls-14.8">14.8</a>).</p>
<blockquote>
<p><code>switch</code> statements differ from <code>switch</code>
expressions in terms of which expressions may appear to the right of an
arrow (<code>-&gt;</code>) in the switch block, that is, which
expressions may be used as <em>switch rule expressions</em>. In a
<code>switch</code> statement, only a statement expression may be used
as a switch rule expression, but in a <code>switch</code> expression,
any expression may be used (<a href="#jls-15.28.1">15.28.1</a>).</p>
</blockquote></li>
<li><p><strong>If the <code>switch</code> statement is an enhanced
<code>switch</code> statement, then it must be
exhaustive.</strong></p></li>
</ul>
<div class="inserted">
<blockquote>
<p>Prior to Java SE 20, <code>switch</code> statements (and
<code>switch</code> expressions) were limited in two ways: (i) the type
of the selector expression was restricted to either an integral type
(excluding <code>long</code>), an enum type, or <code>String</code>; and
(ii) only non-null <code>case</code> constants were supported. Moreover,
unlike <code>switch</code> expressions, <code>switch</code> statements
did not have to be exhaustive. This is often the cause of
difficult-to-detect bugs, where no switch label applies and the
<code>switch</code> statement will silently do nothing. For example:</p>
<pre><code>enum E { A, B, C }

E e = ...;
switch (e) {
   case A -&gt; System.out.println(&quot;A&quot;);
   case B -&gt; System.out.println(&quot;B&quot;);
   // No case for C!
}</code></pre>
<p>With Java SE 20, <code>switch</code> statements have been enhanced in
the sense that along with supporting <code>case</code> patterns, the two
limitations listed above have also been lifted. The designers of the
Java programming language decided that enhanced <code>switch</code>
statements should align with <code>switch</code> expressions and be
required to be exhaustive. This is often achieved with the addition of a
trivial <code>default</code> label. For example, the following enhanced
<code>switch</code> statement is not exhaustive:</p>
<pre><code>Object o = ...;
switch (o) {    // Error - non-exhaustive switch!
    case String s -&gt; System.out.println(&quot;A string!&quot;);
}</code></pre>
<p>but it can easily be made exhaustive:</p>
<pre><code>Object o = ...;
switch (o) {
    case String s -&gt; System.out.println(&quot;A string!&quot;);
    default -&gt; {}
}</code></pre>
<p>For compatibility reasons, <code>switch</code> statements that are
not enhanced <code>switch</code> statements are not required to be
exhaustive.</p>
</blockquote>
<!--
> One consequence of requiring exhaustiveness is that an enhanced `switch`
> statement, unlike a normal `switch` statement, can not have an empty switch
> block.
// This is not true. With GADTs we can have a selector expression with a
// type that none of it permitted subclasses can inhabit, for example:
//
//     sealed class I<X> permits C {}
//     final  class C    extends I<Integer> {}
//
//     I<String> i;
//     switch(i) { };
//     ^^^^
// This is a valid switch statement...
-->
</div>
<h4 id="jls-14.11.3">14.11.3 Execution of a <code>switch</code>
Statement</h4>
<p><strong>An executable</strong> <del>A</del> <code>switch</code>
statement <strong>(<a href="#jls-14.11.1.2">14.11.1.2</a>)</strong> is
executed by first evaluating the selector expression. <del>Then:</del>
If evaluation of the selector expression completes abruptly, then the
entire <code>switch</code> statement completes abruptly for the same
reason.</p>
<div class="deleted">
<ul>
<li><p>Otherwise, if the result of evaluating the selector expression is
<code>null</code>, then a <code>NullPointerException</code> is thrown
and the entire <code>switch</code> statement completes abruptly for that
reason.</p></li>
<li><p>Otherwise, if the result of evaluating the selector expression is
of type <code>Character</code>, <code>Byte</code>, <code>Short</code>,
or <code>Integer</code>, it is subjected to unboxing conversion (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-5.html#jls-5.1.8">5.1.8</a>).
If this conversion completes abruptly, the entire <code>switch</code>
statement completes abruptly for the same reason.</p></li>
</ul>
</div>
<p>If evaluation of the selector expression completes normally <del>and
the result is non-<code>null</code>, and the subsequent unboxing
conversion (if any) completes normally</del>, then execution of the
<code>switch</code> statement continues by determining if a switch label
associated with the <strong>resolved</strong> switch block
<del>matches</del> <strong>applies to</strong> the value of the selector
expression (<a href="#jls-14.11.1.2">14.11.1.2</a>). Then:</p>
<ul>
<li><p><strong>If the process of determining which switch label applies
completes abruptly, then the entire <code>switch</code> statement
completes abruptly for the same reason.</strong></p></li>
<li><p>If no switch label <del>matches, the entire <code>switch</code>
statement completes normally.</del> <strong>applies, then one of the
following holds:</strong></p>
<div class="inserted">
<ul>
<li><p>If the value of the selector expression is <code>null</code>,
then a <code>NullPointerException</code> is thrown and the entire
<code>switch</code> statement completes abruptly for that
reason.</p></li>
<li><p>If the <code>switch</code> statement is an enhanced
<code>switch</code> statement, then a <code>MatchException</code> is
thrown and the entire <code>switch</code> statement completes abruptly
for that reason.</p></li>
<li><p>If the value of the selector expression is not <code>null</code>,
and the <code>switch</code> statement is not an enhanced
<code>switch</code> statement, then the entire <code>switch</code>
statement completes normally.</p></li>
</ul>
</div></li>
<li><p>If a switch label <del>matches</del> <strong>applies</strong>,
then one of the following <del>applies</del> <strong>holds</strong>:</p>
<ul>
<li><p>If it is the switch label for a switch rule expression, then the
switch rule expression is necessarily a statement expression (<a
href="#jls-14.11.2">14.11.2</a>). The statement expression is evaluated.
If the evaluation completes normally, then the <code>switch</code>
statement completes normally. If the result of evaluation is a value, it
is discarded.</p></li>
<li><p>If it is the switch label for a switch rule block, then the block
is executed. If this block completes normally, then the
<code>switch</code> statement completes normally.</p></li>
<li><p>If it is the switch label for a switch rule <code>throw</code>
statement, then the <code>throw</code> statement is executed.</p></li>
<li><p>If it is the switch label for a switch labeled statement group,
then all the statements in the switch block that follow the switch label
are executed in order. If these statements complete normally, then the
<code>switch</code> statement completes normally.</p></li>
<li><p>Otherwise, there are no statements that follow the
<del>matched</del> switch label <strong>that applies</strong> in the
switch block, and the <code>switch</code> statement completes
normally.</p></li>
</ul></li>
</ul>
<p>If execution of any statement or expression in the switch block
completes abruptly, it is handled as follows:</p>
<ul>
<li><p>If execution of a statement completes abruptly because of a
<code>break</code> with no label, then no further action is taken and
the <code>switch</code> statement completes normally.</p>
<blockquote>
<p>Abrupt completion because of a <code>break</code> with a label is
handled by the general rule for labeled statements (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-14.html#jls-14.7">14.7</a>).</p>
</blockquote></li>
<li><p>If execution of a statement or expression completes abruptly for
any other reason, then the <code>switch</code> statement completes
abruptly for the same reason.</p>
<blockquote>
<p>Abrupt completion because of a <code>yield</code> statement is
handled by the general rule for switch expressions (<a
href="#jls-15.28.2">15.28.2</a>).</p>
</blockquote></li>
</ul>
<div class="example">
<p>Example 14.11.3-1. Fall-Through in the <code>switch</code>
Statement</p>
<p>When a <del>selector expression matches a switch label</del>
<strong>switch label applies, and that switch label is</strong> for a
switch rule, the switch rule expression or statement introduced by the
switch label is executed, and nothing else. In the case of a switch
label for a statement group, all the block statements in the switch
block that follow the switch label are executed, including those that
appear after subsequent switch labels. The effect is that, as in C and
C++, execution of statements can "fall through labels."</p>
<p>For example, the program:</p>
<pre><code>class TooMany {
    static void howMany(int k) {
        switch (k) {
            case 1: System.out.print(&quot;one &quot;);
            case 2: System.out.print(&quot;too &quot;);
            case 3: System.out.println(&quot;many&quot;);
        }
    }
    public static void main(String[] args) {
        howMany(3);
        howMany(2);
        howMany(1);
    }
}</code></pre>
<p>contains a <code>switch</code> block in which the code for each
<code>case</code> falls through into the code for the next
<code>case</code>. As a result, the program prints:</p>
<pre><code>many
too many
one too many</code></pre>
<p>Fall through can be the cause of subtle bugs. If code is not to fall
through <code>case</code> to <code>case</code> in this manner, then
<code>break</code> statements can be used to indicate when control
should be transferred, or switch rules can be used, as in the
program:</p>
<pre><code>class TwoMany {
    static void howMany(int k) {
        switch (k) {
            case 1: System.out.println(&quot;one&quot;);
                    break;  // exit the switch
            case 2: System.out.println(&quot;two&quot;);
                    break;  // exit the switch
            case 3: System.out.println(&quot;many&quot;);
                    break;  // not needed, but good style
        }
    }
    static void howManyAgain(int k) {
        switch (k) {
            case 1 -&gt; System.out.println(&quot;one&quot;);
            case 2 -&gt; System.out.println(&quot;two&quot;);
            case 3 -&gt; System.out.println(&quot;many&quot;);
        }
    }
    public static void main(String[] args) {
        howMany(1);
        howMany(2);
        howMany(3);
        howManyAgain(1);
        howManyAgain(2);
        howManyAgain(3);
    }
}</code></pre>
<p>This program prints:</p>
<pre><code>one
two
many
one
two
many</code></pre>
</div>
<h3 id="jls-14.14">14.14 The <code>for</code> Statement</h3>
<h4 id="jls-14.14.2">14.14.2 The enhanced <code>for</code>
statement</h4>
<p>The enhanced <code>for</code> statement has the form:</p>
<dl>
<dt><em>EnhancedForStatement:</em></dt>
<dd>
<code>for</code> <code>(</code>
<del><em>LocalVariableDeclaration</em></del>
<strong>EnhancedForDeclaration</strong> <code>:</code>
<em>Expression</em> <code>)</code><br />
<em>Statement</em>
</dd>
<dt><em>EnhancedForStatementNoShortIf:</em></dt>
<dd>
<code>for</code> <code>(</code>
<del><em>LocalVariableDeclaration</em></del>
<strong>EnhancedForDeclaration</strong> <code>:</code>
<em>Expression</em> <code>)</code><br />
<em>StatementNoShortIf</em>
</dd>
</dl>
<div class="inserted">
<dl>
<dt><em>EnhancedForDeclaration</em>:</dt>
<dd>
<em>LocalVariableDeclaration</em>
</dd>
<dd>
<em>RecordPattern</em>
</dd>
</dl>
</div>
<blockquote>
<p>The following productions from <a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-4.html#jls-4.3">4.3</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-8.html#jls-8.3">8.3</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-8.html#jls-8.4.1">8.4.1</a>,
<del>and</del> <a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-14.html#jls-14.4">14.4</a><strong>,
and <a href="#jls-14.30">14.30</a></strong> are shown here for
convenience:</p>
</blockquote>
<blockquote>
<dl>
<dt><em>LocalVariableDeclaration:</em></dt>
<dd>
{<em>VariableModifier</em>} <em>LocalVariableType</em>
<em>VariableDeclaratorList</em>
</dd>
<dt><em>VariableModifier:</em></dt>
<dd>
<em>Annotation</em>
</dd>
<dd>
<code>final</code>
</dd>
<dt><em>LocalVariableType:</em></dt>
<dd>
<em>UnannType</em>
</dd>
<dd>
<code>var</code>
</dd>
<dt><em>VariableDeclaratorList:</em></dt>
<dd>
<em>VariableDeclarator</em> {<code>,</code> <em>VariableDeclarator</em>}
</dd>
<dt><em>VariableDeclarator:</em></dt>
<dd>
<em>VariableDeclaratorId</em> [<code>=</code>
<em>VariableInitializer</em>]
</dd>
<dt><em>VariableDeclaratorId:</em></dt>
<dd>
<em>Identifier</em> [<em>Dims</em>]
</dd>
<dt><em>Dims:</em></dt>
<dd>
{<em>Annotation</em>} <code>[</code> <code>]</code>
{{<em>Annotation</em>} <code>[</code> <code>]</code>}
</dd>
</dl>
</blockquote>
<div class="inserted">
<blockquote>
<dl>
<dt><em>RecordPattern</em>:</dt>
<dd>
<em>ReferenceType</em> <code>(</code> [ <em>PatternList</em> ]
<code>)</code>
</dd>
<dt><em>PatternList</em>:</dt>
<dd>
<em>Pattern</em> { <code>,</code> <em>Pattern</em> }
</dd>
</dl>
</blockquote>
</div>
<p>The type of the <em>Expression</em> must be an array type (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-10.html#jls-10.1">10.1</a>)
or a subtype of the raw type <code>Iterable</code>, or a compile-time
error occurs.</p>
<p>The <del>header of the enhanced <code>for</code> statement</del>
<strong><em>EnhancedForDeclaration</em> is either (i) a local variable
declaration that</strong> declares a local variable whose name is the
identifier given by <em>VariableDeclaratorId</em><strong>, or (ii) a
record pattern (<a href="#jls-14.30.1">14.30.1</a>)</strong>. When the
enhanced <code>for</code> statement is executed, <strong>then
either</strong> the local variable is initialized, on each iteration of
the loop, to successive elements of the <code>Iterable</code> or the
array produced by the expression<strong>, or on each iteration of the
loop, successive elements of the <code>Iterable</code> or the array
produced by the expression are pattern matched against the record
pattern</strong>.</p>
<div class="inserted">
<p>The <em>iteration type</em> of the <em>Expression</em> is defined as
follows:</p>
<ul>
<li><p>If the <em>Expression</em> has an array type, then the iteration
type is the component type of the array type.</p></li>
<li><p>Otherwise, if the <em>Expression</em> has a type that is a
subtype of <code>Iterable&lt;</code><em>X</em><code>&gt;</code>, for
some type <em>X</em>, then the iteration type is <em>X</em>.</p></li>
<li><p>Otherwise, the <em>Expression</em> has a type that is a subtype
of the raw type <code>Iterable</code>, and the iteration type is
<code>Object</code>.</p></li>
</ul>
</div>
<p><del>The rules for a local variable declared in the header of an
enhanced <code>for</code> statement are specified in <a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-14.html#jls-14.4">14.4</a>,
disregarding any rules in that section which apply when the
<em>LocalVariableType</em> is <code>var</code>.</del></p>
<p><del>In addition, all of the following must be true, or a
compile-time error occurs:</del></p>
<p><strong>If the <em>EnhancedForDeclaration</em> of an enhanced
<code>for</code> statement is a <em>LocalVariableDeclaration</em>, then
both of the following must be true, or a compile-time error
occurs:</strong></p>
<ul>
<li><p>The <em>VariableDeclaratorList</em> consists of a single
<em>VariableDeclarator</em>.</p></li>
<li><p>The <em>VariableDeclarator</em> has no initializer.</p></li>
<li><p><del>The <em>VariableDeclaratorId</em> has no bracket pairs if
the <em>LocalVariableType</em> is <code>var</code>.</del></p></li>
</ul>
<p><strong>For the purposes of the compile-time rules given in <a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-14.html#jls-14.4">14.4</a>,
if the <em>EnhancedForDeclaration</em> of an enhanced <code>for</code>
statement is a <em>LocalVariableDeclaration</em> then it is treated as
if it had an initializer whose type is the <code>for</code> statement's
iteration type.</strong></p>
<div class="editorial">
<p>These changes shift responsibility for the detailed treatment of the
local variable declaration—in particular the treatment of
<code>var</code>—to <a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-14.html#jls-14.4">14.4</a>.
There is no substantive change in how an enhanced <code>for</code> with
a local variable declaration is interpreted.</p>
</div>
<div class="inserted">
<p>If the <em>EnhancedForDeclaration</em> of an enhanced
<code>for</code> statement is a record pattern, then both of the
following must be true, or a compile-time error occurs:</p>
<ul>
<li><p>The record pattern is applicable at the iteration type of the
<code>for</code> statement (<a
href="#jls-14.30.3">14.30.3</a>).</p></li>
<li><p>The set containing the record pattern exhausts the element type
of the <em>Expression</em> (<a
href="#jls-14.11.1.1">14.11.1.1</a>).</p></li>
</ul>
</div>
<p>The scope and shadowing of <del>a</del> <strong>any</strong> local
variable declared in the <del>header</del>
<em>EnhancedForDeclaration</em> of an enhanced <code>for</code>
statement is specified in <a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-6.html#jls-6.3">6.3</a>
and <a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-6.html#jls-6.4">6.4</a>.</p>
<p>References to <del>the</del> <strong>any such</strong> local variable
from a nested class or interface, or a lambda expression, are
restricted, as specified in <a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-6.html#jls-6.5.6.1">6.5.6.1</a>.</p>
<div class="deleted">
<p>The type <em>T</em> of the local variable declared in the header of
the enhanced <code>for</code> statement is determined as follows:</p>
<ul>
<li><p>If the <em>LocalVariableType</em> is <em>UnannType</em>, and no
bracket pairs appear in <em>UnannType</em> or
<em>VariableDeclaratorId</em>, then <em>T</em> is the type denoted by
<em>UnannType</em>.</p></li>
<li><p>If the <em>LocalVariableType</em> is <em>UnannType</em>, and
bracket pairs appear in <em>UnannType</em> or
<em>VariableDeclaratorId</em>, then <em>T</em> is specified by <a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-10.html#jls-10.2">10.2</a>.</p></li>
<li><p>If the <em>LocalVariableType</em> is <code>var</code>, then let
<em>R</em> be derived from the type of the <em>Expression</em>, as
follows:</p>
<ul>
<li><p>If the <em>Expression</em> has an array type, then <em>R</em> is
the component type of the array type.</p></li>
<li><p>Otherwise, if the <em>Expression</em> has a type that is a
subtype of <code>Iterable&lt;</code><em>X</em><code>&gt;</code>, for
some type <em>X</em>, then <em>R</em> is <em>X</em>.</p></li>
<li><p>Otherwise, the <em>Expression</em> has a type that is a subtype
of the raw type <code>Iterable</code>, and <em>R</em> is
<code>Object</code>.</p></li>
</ul>
<p><em>T</em> is the upward projection of <em>R</em> with respect to all
synthetic type variables mentioned by <em>R</em> (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-4.html#jls-4.10.5">4.10.5</a>).</p></li>
</ul>
</div>
<div class="editorial">
<p>These rules are subsumed by the definition of "iteration type" and
the assertion that the local variable declaration is treated as if it
had an initializer of the iteration type.</p>
</div>
<p>The precise meaning of the enhanced <code>for</code> statement is
given by translation into a basic <code>for</code> statement, as
follows:</p>
<ul>
<li><p>If the type of <em>Expression</em> is a subtype of
<code>Iterable</code>, then the basic <code>for</code> statement has
this form:</p>
<pre><code>for (<em>I</em> #i = <em>Expression</em>.iterator(); #i.hasNext(); ) {
    <del><em>{VariableModifier} T Identifier</em> = (<em>TargetType</em>) #i.next();</del>
    <del><em>Statement</em></del>
    <strong>#Body</strong>
}
</code></pre>
<p>where:</p>
<ul>
<li><p>If the type of <em>Expression</em> is a subtype of
<code>Iterable&lt;</code><em>X</em><code>&gt;</code> for some type
argument <em>X</em>, then <em>I</em> is the type
<code>java.util.Iterator&lt;</code><em>X</em><code>&gt;</code>.
Otherwise, <em>I</em> is the raw type
<code>java.util.Iterator</code>.</p></li>
<li><p><code>#i</code> is an automatically generated identifier that is
distinct from any other identifiers (automatically generated or
otherwise) that are in scope (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-6.html#jls-6.3">6.3</a>)
at the point where the enhanced <code>for</code> statement
occurs.</p></li>
</ul>
<div class="deleted">
<ul>
<li><p><em>{VariableModifier}</em> is as given in the header of the
enhanced <code>for</code> statement.</p></li>
<li><p><em>T</em> is the type of the local variable as determined
above.</p></li>
<li><p>If <em>T</em> is a reference type, then <em>TargetType</em> is
<em>T</em>. Otherwise, <em>TargetType</em> is the upper bound of the
capture conversion (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-5.html#jls-5.1.10">5.1.10</a>)
of the type argument of <em>I</em>, or <code>Object</code> if <em>I</em>
is raw.</p></li>
</ul>
</div>
<ul>
<li><div class="inserted">
<p>If the <em>EnhancedForDeclaration</em> of the enhanced
<code>for</code> statement is a <em>LocalVariableDeclaration</em>, then
<code>#Body</code> is the following:</p>
<pre><code><em>LocalVariableDeclaration</em> = #i.next();
<em>Statement</em>
</code></pre>
</div>
<div class="editorial">
<p>This removes the cast to <em>TargetType</em>. As discussed in <a
href="https://bugs.openjdk.org/browse/JDK-6690688">JDK-6690688</a>, the
cast may have helped provide clarity, but was not formally necessary—any
erasure-related casts are already specified as a consequence of
assignment conversion (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-5.html#jls-5.2">5.2</a>).
With the addition of record patterns, the extra complexity is no longer
helpful.</p>
</div>
<div class="inserted">
<p>Otherwise, the <em>EnhancedForDeclaration</em> of the enhanced
<code>for</code> statement is a <em>RecordPattern</em>, and
<code>#Body</code> is the following:</p>
<pre><code>switch(#i.next()) {
    case null -> throw new MatchException(new NullPointerException());
    case <em>RecordPattern</em> -> <em>Statement</em>
}
</code></pre>
</div></li>
</ul></li>
<li><p>Otherwise, the <em>Expression</em> necessarily has an array type,
<em>S</em><code>[]</code>, and the basic <code>for</code> statement has
this form:</p>
<pre><code><em>S</em>[] #a = <em>Expression</em>;
<em>L<sub>1</sub></em>: <em>L<sub>2</sub></em>: ... <em>L<sub>m</sub></em>:
for (int #i = 0; #i < #a.length; #i++) {
    <del><em>{VariableModifier} T Identifier</em> = #a[#i];</del>
    <del><em>Statement</em></del>
    <strong>#Body</strong>
}
</code></pre>
<p>where:</p>
<ul>
<li><p><em>L<sub>1</sub></em> ... <em>L<sub>m</sub></em> is the
(possibly empty) sequence of labels immediately preceding the enhanced
<code>for</code> statement.</p></li>
<li><p><code>#a</code> and <code>#i</code> are automatically generated
identifiers that are distinct from any other identifiers (automatically
generated or otherwise) that are in scope at the point where the
enhanced <code>for</code> statement occurs.</p></li>
</ul>
<div class="deleted">
<ul>
<li><p><em>{VariableModifier}</em> is as given in the header of the
enhanced <code>for</code> statement.</p></li>
<li><p><em>T</em> is the type of the local variable as determined
above.</p></li>
</ul>
</div>
<div class="inserted">
<ul>
<li><p>If the <em>EnhancedForDeclaration</em> of the enhanced
<code>for</code> statement is a <em>LocalVariableDeclaration</em>, then
<code>#Body</code> is the following:</p>
<pre><code><em>LocalVariableDeclaration</em> = #a[#i];
<em>Statement</em>
</code></pre>
<p>Otherwise, the <em>EnhancedForDeclaration</em> of the enhanced
<code>for</code> statement is a <em>RecordPattern</em>, and
<code>#Body</code> is the following:</p>
<pre><code>switch(#a[#i]) {
    case null -> throw new MatchException(new NullPointerException());
    case <em>RecordPattern</em> -> <em>Statement</em>
}
</code></pre></li>
</ul>
</div></li>
</ul>
<blockquote>
<p>For example, this code:</p>
<pre><code>List&lt;? extends Integer&gt; l = ...
for (float i : l) ...</code></pre>
<p>will be translated to:</p>
<div class="deleted">
<pre><code>for (Iterator&lt;Integer&gt; #i = l.iterator(); #i.hasNext(); ) {
    float #i0 = (Integer)#i.next();
    ...</code></pre>
</div>
<div class="inserted">
<pre><code>for (Iterator&lt;Integer&gt; #i = l.iterator(); #i.hasNext(); ) {
    float #i0 = #i.next();
    ...
}</code></pre>
</div>
</blockquote>
<div class="example">
<p>Example 14.14-1. Enhanced <code>for</code> And Arrays</p>
<p>The following program, which calculates the sum of an integer array,
shows how enhanced <code>for</code> works for arrays:</p>
<pre><code>int sum(int[] a) {
    int sum = 0;
    for (int i : a) sum += i;
    return sum;
}</code></pre>
</div>
<div class="example">
<p>Example 14.14-2. Enhanced <code>for</code> And Unboxing
Conversion</p>
<p>The following program combines the enhanced <code>for</code>
statement with auto-unboxing to translate a histogram into a frequency
table:</p>
<pre><code>Map&lt;String, Integer&gt; histogram = ...;
double total = 0;
for (int i : histogram.values())
    total += i;
for (Map.Entry&lt;String, Integer&gt; e : histogram.entrySet())
    System.out.println(e.getKey() + &quot; &quot; + e.getValue() / total);
}</code></pre>
</div>
<h3 id="jls-14.30">14.30 Patterns</h3>
<p>A <em>pattern</em> describes a test that can be performed on a value.
Patterns appear as operands of statements and expressions, which provide
the values to be tested. Patterns <strong>may</strong> declare local
variables, known as <em>pattern variables</em>.</p>
<p>The process of testing a value against a pattern is known as
<em>pattern matching</em>. If a value successfully matches a pattern,
then the process of pattern matching initializes the pattern
<del>variable</del> <strong>variables, if any,</strong> declared by the
pattern.</p>
<p>Pattern variables are only in scope (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-6.html#jls-6.3">6.3</a>)
where pattern matching succeeds and thus the pattern variables will have
been initialized. It is not possible to use a pattern variable that has
not been initialized.</p>
<h4 id="jls-14.30.1">14.30.1 Kinds of Patterns</h4>
<p>A <em>type pattern</em> is used to test whether a value is an
instance of the type appearing in the pattern. <strong>A <em>record
pattern</em> is used to test whether a value is an instance of a record
class type and, if it is, to recursively perform pattern matching on the
record component values. A pattern may be parenthesized to assist in
readability.</strong></p>
<dl>
<dt><em>Pattern</em>:</dt>
<dd>
<em>TypePattern</em>
</dd>
<dd>
<strong><em>RecordPattern</em></strong>
</dd>
<dd>
<strong><em>ParenthesizedPattern</em></strong>
</dd>
<dt><em>TypePattern</em>:</dt>
<dd>
<em>LocalVariableDeclaration</em>
</dd>
</dl>
<div class="inserted">
<dl>
<dt><em>RecordPattern</em>:</dt>
<dd>
<em>ReferenceType</em> <code>(</code> [ <em>PatternList</em> ]
<code>)</code>
</dd>
<dt><em>PatternList</em> :</dt>
<dd>
<em>Pattern</em> { <code>,</code> <em>Pattern</em> }
</dd>
<dt><em>ParenthesizedPattern</em>:</dt>
<dd>
<code>(</code> <em>Pattern</em> <code>)</code>
</dd>
</dl>
</div>
<blockquote>
<p>The following productions from <a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-4.html#jls-4.3">4.3</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-8.html#jls-8.3">8.3</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-8.html#jls-8.4.1">8.4.1</a>,
and <a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-14.html#jls-14.4">14.4</a>
are shown here for convenience:</p>
</blockquote>
<blockquote>
<dl>
<dt><em>LocalVariableDeclaration:</em></dt>
<dd>
{<em>VariableModifier</em>} <em>LocalVariableType</em>
<em>VariableDeclaratorList</em>
</dd>
<dt><em>VariableModifier:</em></dt>
<dd>
<em>Annotation</em>
</dd>
<dd>
<code>final</code>
</dd>
<dt><em>LocalVariableType:</em></dt>
<dd>
<em>UnannType</em>
</dd>
<dd>
<code>var</code>
</dd>
<dt><em>VariableDeclaratorList:</em></dt>
<dd>
<em>VariableDeclarator</em> {<code>,</code> <em>VariableDeclarator</em>}
</dd>
<dt><em>VariableDeclarator:</em></dt>
<dd>
<em>VariableDeclaratorId</em> [<code>=</code>
<em>VariableInitializer</em>]
</dd>
<dt><em>VariableDeclaratorId:</em></dt>
<dd>
<em>Identifier</em> [<em>Dims</em>]
</dd>
<dt><em>Dims:</em></dt>
<dd>
{<em>Annotation</em>} <code>[</code> <code>]</code>
{{<em>Annotation</em>} <code>[</code> <code>]</code>}
</dd>
</dl>
</blockquote>
<blockquote>
<p>See <a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-8.html#jls-8.3">8.3</a>
for <em>UnannType</em>.</p>
</blockquote>
<!-- Details about type patterns -->
<p>A type pattern declares one local variable, known as a pattern
variable. The <em>Identifier</em> in the local variable declaration
specifies the name of the pattern variable.</p>
<div class="inserted">
<p>A type pattern that does not appear as an element in the nested
pattern list of a record pattern is called a <em>top-level type
pattern</em>.</p>
</div>
<p>The rules for a local variable declared in a type pattern are
specified in <a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-14.html#jls-14.4">14.4</a>.
In addition, all of the following must be true, or a compile-time error
occurs:</p>
<ul>
<li><p>The <em>LocalVariableType</em> <strong>in a top-level type
pattern</strong> denotes a reference type (and furthermore is not
<code>var</code>).</p></li>
<li><p>The <em>VariableDeclaratorList</em> consists of a single
<em>VariableDeclarator</em>.</p></li>
<li><p>The <em>VariableDeclarator</em> has no initializer.</p></li>
<li><p>The <em>VariableDeclaratorId</em> has no bracket pairs.</p></li>
</ul>
<p>The type of a pattern variable <strong>declared in a top-level type
pattern</strong> is the reference type denoted by
<em>LocalVariableType</em>.</p>
<div class="inserted">
<p>The type of a pattern variable declared in a type pattern that is not
a top-level type pattern is determined as follows:</p>
<ul>
<li><p>If the <em>LocalVariableType</em> is <em>UnannType</em> then the
type of the pattern variable is denoted by <em>UnannType</em></p></li>
<li><p>If the <em>LocalVariableType</em> is <code>var</code> then the
pattern variable must appear in a pattern list of a record pattern with
type <em>R</em>. Let <em>T</em> be the type of the corresponding
component field in <em>R</em>. The type of the pattern variable is the
upward projection of <em>T</em> with respect to all synthetic type
variables mentioned by <em>T</em>.</p>
<blockquote>
<p>Consider the following record declaration:</p>
<pre><code>record R&lt;T&gt;(ArrayList&lt;T&gt; r){}</code></pre>
<p>Given the pattern <code>R&lt;String&gt;(var r)</code>, the type of
the pattern variable <code>r</code> is thus
<code>ArrayList&lt;String&gt;</code>.</p>
</blockquote></li>
</ul>
</div>
<p><del>The type of a type pattern is the type of its pattern
variable.</del></p>
<!-- Details about Record Patterns -->
<div class="inserted">
<p>A record pattern consists of a <em>ReferenceType</em> and a nested
pattern list. If <em>ReferenceType</em> is not a record class type (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-8.html#jls-8.10">8.10</a>)
then a compile-time error occurs.</p>
<p>If the <em>ReferenceType</em> is a raw type, then the type of the
record pattern is inferred, as described in <a
href="#jls-18.5.5">18.5.5</a>. It is a compile-time error if no type can
be inferred for the record pattern.</p>
<p>Otherwise, the type of the record pattern is
<em>ReferenceType</em>.</p>
<p>The length of the record pattern's nested pattern list must be the
same as the length of the record component list in the declaration of
the record class named by <em>ReferenceType</em>; otherwise a
compile-time error occurs.</p>
<blockquote>
<p>Currently, there is no support for variable arity record patterns.
This may be supported in future versions of the Java Programming
Language.</p>
</blockquote>
<p>A record pattern declares the local variables, if any, that are
declared by the patterns in the nested pattern list.</p>
</div>
<!-- Details about parenthesized patterns -->
<div class="inserted">
<p>A parenthesized pattern declares the local variables that are
declared by the contained pattern.</p>
</div>
<!-- Details about Any Patterns -->
<div class="inserted">
<p>There is also a special <em>any pattern</em>, which is a pattern that
arises from the process of resolving a pattern (<a
href="#jls-14.30.2">14.30.2</a>).</p>
<blockquote>
<p>Currently, no syntax exists for any patterns so they can not be used
as a pattern in a pattern <code>instanceof</code> expression, or as a
pattern in a switch label of a <code>switch</code> expression or
<code>switch</code> statement. It is possible that future versions of
the Java programming language may relax this restriction.</p>
</blockquote>
<p>An any pattern declares one local variable, known as a pattern
variable.</p>
<p>The pattern variable declared by an any pattern has a type, which is
a reference type.</p>
</div>
<!-- General details about patterns -->
<div class="deleted">
<p>An expression <em>e</em> is <em>compatible</em> with a pattern of
type <em>T</em> if <em>e</em> is downcast compatible with <em>T</em> (<a
href="#jls-5.5">5.5</a>).</p>
<blockquote>
<p>Compatibility of an expression with a pattern is used by the
<code>instanceof</code> pattern match operator (<a
href="#jls-15.20.2">15.20.2</a>).</p>
</blockquote>
</div>
<h4 id="jls-14.30.2">14.30.2 Pattern Matching</h4>
<p><em>Pattern matching</em> is the process of testing a value against a
pattern at run time. Pattern matching is distinct from statement
execution (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-14.html#jls-14.1">14.1</a>)
and expression evaluation (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-15.html#jls-15.1">15.1</a>).
<strong>If a value successfully matches a pattern, then the process of
pattern matching will initialize all the pattern variables declared by
the pattern, if any.</strong></p>
<div class="inserted">
<p>Before pattern matching is performed, all patterns are first
<em>resolved</em> with respect to the type of the expression that they
are to be matched against (either the selector expression of a
<code>switch</code> statement or <code>switch</code> statement, or the
<em>RelationalExpression</em> of an <code>instanceof</code> expression),
resulting in a possibly amended pattern.</p>
<p>Resolving a pattern at type <em>U</em> is specified as follows:</p>
<ul>
<li>A type pattern, <em>p</em>, declaring a pattern variable <em>x</em>
of type <em>T</em>, is resolved to an any pattern that declares
<em>x</em> of type <em>T</em> if <em>p</em> is unconditional at
<em>U</em>; otherwise it is resolved to <em>p</em>.</li>
</ul>
<!---   An any pattern, *p*, is resolved to *p*.-->
<ul>
<li><p>A record pattern <em>p</em> with type <em>R</em> and nested
pattern list <em>L</em> is resolved to a record pattern with type
<em>R</em> and the nested pattern list resulting from resolving, in
order, each pattern in <em>L</em>, if any, at the type of the
corresponding component field in <em>R</em>. type of the corresponding
component field in <em>R</em>.</p></li>
<li><p>A parenthesized pattern, with contained pattern <em>p</em>, is
resolved to a parenthesized pattern whose contained pattern is the
result of resolving <em>p</em> at type <em>U</em>.</p></li>
</ul>
<!--
> This process of resolving a pattern addresses a problem that arises when
> matching a null reference value against a type pattern. Checking whether a
> value matches a type pattern of type *U* involves checking (at runtime)
> whether the value can be cast to *U*. But the null reference can be cast to
> any reference type without any checks. If an expression of type *V* ultimately
> evaluates to the null reference, we'd still expect the match to only succeed
> if *V* was a subtype of the type of the type pattern.
>
> This suggests that pattern matching needs to involve compile-time types.
> Rather than directly defining the runtime process of pattern matching with
> reference to compile-time types, we instead observe that pattern matching
> should satisfy the following property: the value of any expression whose
> static type is *T* always matches a type pattern of type *S*, where *T* is a
> subtype of *S*.
>
> Thus, at compile-time we "resolve" the pattern with respect to the
> (compile-time) type of the expression being pattern matched. If it can be
> determined at compile-time that a pattern will always match, it is translated,
> or resolved, to a special any pattern (which, by definition, all values match
> without any examination of runtime types). This ensures the expected behavior
> when the value being matched is the null reference. In the other cases,
> resolving a pattern leaves the pattern untouched.
-->
<blockquote>
<p>This process of resolving a pattern is to capture the correct
semantics of record patterns. Consider, for example:</p>
<pre><code>class Super {}
class Sub extends Super {}
record R(Super s) {}</code></pre>
<p>We expect all non-null values of type <em>R</em> to match the pattern
<code>R(Super s)</code>, including the value resulting from evaluating
the expression <code>new R(null)</code>. (Even though the null value
does not match the pattern <code>Super s</code>.) However, we would
<em>not</em> expect this value to match the pattern
<code>R(Sub</code> <code>s)</code> as the null value for the record
component does not match the pattern <code>Sub s</code>.</p>
<p>The meaning of a pattern occurring in a nested pattern list is then
determined with respect to the record declaration. Resolution replaces
any type patterns appearing in a nested pattern list that should match
all values including null with instances of the special any pattern. In
our example above, the pattern <code>R(Sub s)</code> is resolved to the
pattern <code>R(Sub s)</code>, whereas the pattern
<code>R(Super s)</code> is resolved to a record pattern with type
<code>R</code> and a nested pattern list containing an any pattern.</p>
</blockquote>
<p>The process of pattern matching may involve expression evaluation or
statement execution. Accordingly, pattern matching is said to
<em>complete abruptly</em> if evaluation of a expression or execution of
a statement completes abruptly. An abrupt completion always has an
associated reason, which is always a <code>throw</code> with a given
value. Pattern matching is said to <em>complete normally</em> if it does
not complete abruptly.</p>
</div>
<p>The rules for determining whether a value matches a
<strong>resolved</strong> pattern, and for initializing pattern
variables, are as follows:</p>
<div class="inserted">
<ul>
<li><p>The null reference <em>matches</em> an any pattern.</p>
<p>The pattern variable declared by the any pattern is initialized to
the null reference.</p></li>
<li><p>A value <em>v</em> that is not the null reference
<em>matches</em> an any pattern of type <em>T</em> if <em>v</em> can be
cast to <em>T</em> without raising a <code>ClassCastException</code>;
and <em>does not match</em> otherwise.</p>
<p>If <em>v</em> matches, then the pattern variable declared by the any
pattern is initialized to <em>v</em>.</p>
<p>If <em>v</em> does not match, then the pattern variable declared by
the any pattern is not initialized.</p></li>
<li><p>The null reference <em>does not match</em> a type pattern.</p>
<p>In this case, the pattern variable declared by the type pattern is
not initialized.</p></li>
</ul>
</div>
<ul>
<li><p>A value <em>v</em> that is not the null reference
<em>matches</em> a type pattern of type <em>T</em> if <em>v</em> can be
cast to <em>T</em> without raising a <code>ClassCastException</code>;
and <em>does not match</em> otherwise.</p>
<p>If <em>v</em> matches, then the pattern variable declared by the type
pattern is initialized to <em>v</em>.</p>
<p>If <em>v</em> does not match, then the pattern variable declared by
the type pattern is not initialized.</p></li>
</ul>
<div class="inserted">
<ul>
<li><p>The null reference <em>does not match</em> a record pattern.</p>
<p>In this case, any pattern variables declared by the record pattern
are not initialized.</p></li>
<li><p>A value <em>v</em> that is not the null reference
<em>matches</em> a record pattern with type <em>R</em> and nested
pattern list <em>L</em> if (i) <em>v</em> can be cast to <em>R</em>
without raising a <code>ClassCastException</code>; and (ii) each record
component of <em>v</em> matches the corresponding pattern in <em>L</em>;
and <em>does not match</em> otherwise.</p>
<p>Each record component of <em>v</em> is determined by invoking the
accessor method of <em>v</em> corresponding to that component. If
execution of the invocation of the accessor method completes abruptly
for reason <em>S</em>, then pattern matching completes abruptly by
throwing a <code>MatchException</code> with cause <em>S</em>.</p>
<blockquote>
<p>Any pattern variable declared in a pattern appearing in the record
component pattern list is initialized only if <em>all</em> the patterns
in the list match.</p>
</blockquote></li>
<li><p>A value <em>matches</em> a parenthesized pattern if it matches
the contained pattern; and <em>does not match</em> otherwise.</p></li>
</ul>
</div>
<div class="deleted">
<blockquote>
<p>There is no rule to cover a value that <em>is</em> the null
reference. This is because the solitary construct that performs pattern
matching, the <code>instanceof</code> pattern match operator (<a
href="#jls-15.20.2">15.20.2</a>), only does so when a value is
<em>not</em> the null reference. It is possible that future versions of
the Java programming language will allow pattern matching in other
expressions and statements.</p>
</blockquote>
</div>
<h4 id="jls-14.30.3"><strong>14.30.3 Properties of
Patterns</strong></h4>
<div class="inserted">
<p>A pattern <em>p</em> is said to be <em>applicable</em> at a type
<em>T</em> if one of the following rules apply:</p>
<ul>
<li><p>A type pattern that declares a pattern variable of a reference
type <em>U</em> is applicable at another reference type <em>T</em> if
<em>T</em> is downcast convertible to <em>U</em> (<a
href="#jls-5.5">5.5</a>).</p></li>
<li><p>A type pattern that declares a pattern variable of a primitive
type <em>P</em> is applicable at the type <em>P</em>.</p></li>
<li><p>A parenthesized pattern is applicable at type <em>T</em> if its
contained pattern is applicable at type <em>T</em>.</p></li>
<li><p>A record pattern with type <em>R</em> and nested pattern list
<em>L</em> is applicable at type <em>T</em> if (i) <em>T</em> is
downcast convertible to <em>R</em>, and (ii) for every pattern
<em>p</em> appearing in <em>L</em>, if any, <em>p</em> is applicable at
the type of the corresponding component field in <em>R</em> (<a
href="#jls-5.5">5.5</a>).</p></li>
</ul>
<p>A pattern <em>p</em> is said to be <em>unconditional</em> at a type
<em>T</em> if every value of type <em>T</em> will match <em>p</em>
(after <em>p</em> has been resolved at type <em>T</em> (<a
href="#jls-14.30.2">14.30.2</a>)), and is defined as follows:</p>
<ul>
<li><p>A type pattern that declares a pattern variable of a reference
type <em>S</em> is unconditional at another reference type <em>T</em> if
the erasure of <em>T</em> is a subtype of the erasure of
<em>S</em>.</p></li>
<li><p>A type pattern that declares a pattern variable of a primitive
type <em>P</em> is unconditional at the type <em>P</em>.</p></li>
<li><p>A parenthesized pattern is unconditional at a type <em>T</em> if
its contained pattern is unconditional at <em>T</em>.</p></li>
</ul>
<blockquote>
<p>Note that record patterns are not unconditional at any type because
the null reference does not match any record pattern.</p>
</blockquote>
<p>A pattern <em>p</em> is said to <em>dominate</em> another pattern
<em>q</em> if every value that matches <em>q</em> also matches
<em>p</em>, and is defined as follows:</p>
<ul>
<li><p>A pattern <em>p</em> dominates a type pattern that declares a
pattern variable of type <em>T</em> if <em>p</em> is unconditional at
<em>T</em>.</p></li>
<li><p>A pattern <em>p</em> dominates a parenthesized pattern with
contained pattern <em>q</em> if <em>p</em> dominates
<em>q</em>.</p></li>
<li><p>A pattern <em>p</em> dominates a record pattern with type
<em>R</em> if <em>p</em> is unconditional at <em>R</em>.</p></li>
<li><p>A record pattern with type <em>R</em> and nested pattern list
<em>L</em> dominates another record pattern with type <em>S</em> and
nested pattern list <em>M</em> if (i) the erasure of <em>S</em> is a
subtype of the erasure of <em>R</em>, and (ii) every pattern, if any, in
<em>L</em> dominates the corresponding pattern in <em>M</em>.</p></li>
</ul>
</div>
<h2 id="jls-15">Chapter 15: Expressions</h2>
<h3 id="jls-15.20">15.20 Relational Operators</h3>
<h4 id="jls-15.20.2">15.20.2 The <code>instanceof</code> Operator</h4>
<p>An <code>instanceof</code> expression may perform either type
comparison or pattern matching.</p>
<dl>
<dt><em>InstanceofExpression:</em></dt>
<dd>
<em>RelationalExpression</em> <code>instanceof</code>
<em>ReferenceType</em>
</dd>
<dd>
<em>RelationalExpression</em> <code>instanceof</code> <em>Pattern</em>
</dd>
</dl>
<p>If the operand to the right of the <code>instanceof</code> keyword is
a <em>ReferenceType</em>, then the <code>instanceof</code> keyword is
the <em>type comparison operator</em>.</p>
<p>If the operand to the right of the <code>instanceof</code> keyword is
a <em>Pattern</em>, then the <code>instanceof</code> keyword is the
<em>pattern match operator</em>.</p>
<p>The following rules apply when <code>instanceof</code> is the type
comparison operator:</p>
<ul>
<li><p>The type of the expression <em>RelationalExpression</em> must be
a reference type or the null type, or a compile-time error
occurs.</p></li>
<li><p>The <em>RelationalExpression</em> must be downcast compatible
with the <em>ReferenceType</em> (<a href="#jls-5.5">5.5</a>), or a
compile-time error occurs.</p></li>
<li><p>At run time, the result of the type comparison operator is
determined as follows:</p>
<ul>
<li><p>If the value of the <em>RelationalExpression</em> is the null
reference (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-4.html#jls-4.1">4.1</a>),
then the result is <code>false</code>.</p></li>
<li><p>If the value of the <em>RelationalExpression</em> is not the null
reference, then the result is <code>true</code> if the value could be
cast to the <em>ReferenceType</em> without raising a
<code>ClassCastException</code>, and <code>false</code>
otherwise.</p></li>
</ul></li>
</ul>
<p>The following rules apply when <code>instanceof</code> is the pattern
match operator:</p>
<ul>
<li><p>The type of the expression <em>RelationalExpression</em> must be
a reference type or the null type, or a compile-time error
occurs.</p></li>
<li><p><del>The <em>RelationalExpression</em> must be compatible with
the <em>Pattern</em> (<a href="#jls-14.30.1">14.30.1</a>), or a
compile-time error occurs.</del> <strong>The <em>Pattern</em> must be
applicable at the type of the expression <em>RelationalExpression</em>
(<a href="#jls-14.30.3">14.30.3</a>), or a compile-time error
occurs.</strong></p></li>
<li><p><del>If the type of the <em>RelationalExpression</em> is a
subtype of the type of the <em>Pattern</em>, then a compile-time error
occurs.</del></p></li>
<li><p><strong>Before pattern matching is performed, all patterns are
first <em>resolved</em> (<a href="#jls-14.30.2">14.30.2</a>). An
<em>executable</em> pattern match operator is one where the
<em>Pattern</em> has been resolved at the type of the
<em>RelationalExpression</em>.</strong></p></li>
<li><p>At run time, the result of the <strong>executable</strong>
pattern match operator is determined as follows:</p>
<ul>
<li><p>If the value of the <em>RelationalExpression</em> is the null
reference, then the result is <code>false</code>.</p></li>
<li><p>If the value of the <em>RelationalExpression</em> is not the null
reference, then the result is <code>true</code> if the value matches the
<em>Pattern</em> (<a href="#jls-14.30.2">14.30.2</a>), and
<code>false</code> otherwise.</p>
<blockquote>
<p>A side effect of a <code>true</code> result is that <strong>all
the</strong> pattern variables declared in <em>Pattern</em><strong>, if
any,</strong> will be initialized.</p>
</blockquote></li>
</ul></li>
</ul>
<div class="example">
<p>Example 15.20.2-1. The Type Comparison Operator</p>
<pre><code>class Point   { int x, y; }
class Element { int atomicNumber; }
class Test {
    public static void main(String[] args) {
        Point   p = new Point();
        Element e = new Element();
        if (e instanceof Point) {  // compile-time error
            System.out.println(&quot;I get your point!&quot;);
            p = (Point)e;  // compile-time error
        }
    }
}</code></pre>
<p>This program results in two compile-time errors. The cast
<code>(Point)e</code> is incorrect because no instance of
<code>Element</code> or any of its possible subclasses (none are shown
here) could possibly be an instance of any subclass of
<code>Point</code>. The <code>instanceof</code> expression is incorrect
for exactly the same reason. If, on the other hand, the class
<code>Point</code> were a subclass of <code>Element</code> (an
admittedly strange notion in this example):</p>
<pre><code>class Point extends Element { int x, y; }</code></pre>
<p>then the cast would be possible, though it would require a run-time
check, and the <code>instanceof</code> expression would then be sensible
and valid. The cast <code>(Point)e</code> would never raise an exception
because it would not be executed if the value of <code>e</code> could
not correctly be cast to type <code>Point</code>.</p>
<p>Prior to Java SE 16, the <em>ReferenceType</em> operand of a type
comparison operator was required to be reifiable (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-4.html#jls-4.7">4.7</a>).
This prevented the use of a parameterized type unless all its type
arguments were wildcards. The requirement was lifted in Java SE 16 to
allow more parameterized types to be used. For example, in the following
program, it is legal to test whether the method parameter
<code>x</code>, with static type <code>List&lt;Integer&gt;</code>, has a
more "refined" parameterized type <code>ArrayList&lt;Integer&gt;</code>
at run time:</p>
<pre><code>import java.util.ArrayList;
import java.util.List;

class Test2 {
    public static void main(String[] args) {
        List&lt;Integer&gt; x = new ArrayList&lt;Integer&gt;();

        if (x instanceof ArrayList&lt;Integer&gt;) {  // OK
            System.out.println(&quot;ArrayList of Integers&quot;);
        }
        if (x instanceof ArrayList&lt;String&gt;) {  // error
            System.out.println(&quot;ArrayList of Strings&quot;);
        }
        if (x instanceof ArrayList&lt;Object&gt;) {  // error
            System.out.println(&quot;ArrayList of Objects&quot;);
        }
    }
}</code></pre>
<p>The first <code>instanceof</code> expression is legal because there
is a casting conversion from <code>List&lt;Integer&gt;</code> to
<code>ArrayList&lt;Integer&gt;</code>. However, the second and third
<code>instanceof</code> expressions both cause a compile-time error
because there is no casting conversion from
<code>List&lt;Integer&gt;</code> to <code>ArrayList&lt;String&gt;</code>
or <code>ArrayList&lt;Object&gt;</code>.</p>
</div>
<h3 id="jls-15.28">15.28 <code>switch</code> Expressions</h3>
<p>A <code>switch</code> expression transfers control to one of several
statements or expressions, depending on the value of an expression; all
possible values of that expression must be handled, and all of the
several statements and expressions must produce a value for the result
of the <code>switch</code> expression.</p>
<dl>
<dt><em>SwitchExpression:</em></dt>
<dd>
<code>switch</code> <code>(</code> <em>Expression</em> <code>)</code>
<em>SwitchBlock</em>
</dd>
</dl>
<p>The <em>Expression</em> is called the <em>selector expression</em>.
<del>The type of the selector expression must be <code>char</code>,
<code>byte</code>, <code>short</code>, <code>int</code>,
<code>Character</code>, <code>Byte</code>, <code>Short</code>,
<code>Integer</code>, <code>String</code>, or an enum type (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-8.html#jls-8.9">8.9</a>),
or a compile-time error occurs.</del></p>
<blockquote>
<p>The body of both a <code>switch</code> expression and a
<code>switch</code> statement (<a href="#jls-14.11">14.11</a>) is called
a <em>switch block</em>. General rules which apply to all switch blocks,
whether they appear in <code>switch</code> expressions or
<code>switch</code> statements, are given in <a
href="#jls-14.11.1">14.11.1</a>. The following productions from <a
href="#jls-14.11.1">14.11.1</a> are shown here for convenience:</p>
<dl>
<dt><em>SwitchBlock:</em></dt>
<dd>
<code>{</code> <em>SwitchRule</em> {<em>SwitchRule</em>} <code>}</code>
</dd>
<dd>
<code>{</code> {<em>SwitchBlockStatementGroup</em>}
{<em>SwitchLabel</em> <code>:</code>} <code>}</code>
</dd>
<dt><em>SwitchRule:</em></dt>
<dd>
<em>SwitchLabel</em> <code>-&gt;</code> <em>Expression</em>
<code>;</code>
</dd>
<dd>
<em>SwitchLabel</em> <code>-&gt;</code> <em>Block</em>
</dd>
<dd>
<em>SwitchLabel</em> <code>-&gt;</code> <em>ThrowStatement</em>
</dd>
<dt><em>SwitchBlockStatementGroup:</em></dt>
<dd>
<em>SwitchLabel</em> <code>:</code> { <em>SwitchLabel</em>
<code>:</code>} <em>BlockStatements</em>
</dd>
</dl>
<div class="deleted">
<dl>
<dt><em>SwitchLabel:</em></dt>
<dd>
<code>case</code> <em>CaseConstant</em> {<code>,</code>
<em>CaseConstant</em>}
</dd>
<dd>
<code>default</code>
</dd>
</dl>
</div>
<div class="inserted">
<dl>
<dt><em>SwitchLabel</em>:</dt>
<dd>
<code>case</code> <em>CaseConstant</em> {<code>,</code>
<em>CaseConstant</em> }
</dd>
<dd>
<code>case</code> <em>CasePattern</em>
</dd>
<dd>
<code>case null</code> [<code>, default</code>]
</dd>
<dd>
<code>default</code>
</dd>
</dl>
</div>
<dl>
<dt><em>CaseConstant:</em></dt>
<dd>
<em>ConditionalExpression</em>
</dd>
</dl>
<div class="inserted">
<dl>
<dt><em>CasePattern</em>:</dt>
<dd>
<em>Pattern</em> [ <em>Guard</em> ]
</dd>
<dt><em>Guard</em>:</dt>
<dd>
<code>when</code> <em>Expression</em>
</dd>
</dl>
</div>
</blockquote>
<h4 id="jls-15.28.1">15.28.1 The Switch Block of a <code>switch</code>
Expression</h4>
<p>In addition to the general rules for switch blocks (<a
href="#jls-14.11.1">14.11.1</a>), there are further rules for switch
blocks in <code>switch</code> expressions.</p>
<div class="deleted">
<p>Namely, all of the following must be true for the switch block of a
<code>switch</code> expression, or a compile-time error occurs:</p>
<ul>
<li><p>If the type of the selector expression is not an enum type, then
there is exactly one <code>default</code> label associated with the
switch block.</p></li>
<li><p>If the type of the selector expression is an enum type, then (i)
the set of the <code>case</code> constants associated with the switch
block includes every enum constant of the enum type, and (ii) at most
one <code>default</code> label is associated with the switch block.</p>
<blockquote>
<p>A <code>default</code> label is permitted, but not required, when the
<code>case</code> labels cover all the enum constants.</p>
</blockquote></li>
</ul>
</div>
<p><del>If</del> <strong>It is a compile-time error if</strong> the
switch block <strong>of a <code>switch</code> expression</strong>
consists of switch rules, <del>then any switch rule block cannot</del>
<strong>but one or more switch rule blocks can</strong> complete
normally (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-14.html#jls-14.22">14.22</a>).</p>
<p><del>If</del> <strong>It is a compile-time error if</strong> the
switch block <strong>of a <code>switch</code> expression</strong>
consists of switch labeled statement groups, <del>then</del>
<strong>but</strong> the last statement in the switch block
<del>cannot</del> <strong>can</strong> complete normally, <del>and</del>
<strong>or</strong> the switch block <del>does not have any</del>
<strong>has one or more</strong> switch labels after the last switch
labeled statement group.</p>
<p><strong>It is a compile-time error if a <code>switch</code>
expression is not exhaustive (<a
href="#jls-14.11.1.1">14.11.1.1</a>).</strong></p>
<blockquote>
<p><del><code>switch</code> expressions cannot have empty switch blocks,
unlike <code>switch</code> statements.</del></p>
</blockquote>
<div class="editorial">
<p>This is covered by the result expression requirement, below.</p>
</div>
<blockquote>
<p><del>Furthermore,</del> <code>switch</code> expressions differ from
<code>switch</code> statements in terms of which expressions may appear
to the right of an arrow (<code>-&gt;</code>) in the switch block, that
is, which expressions may be used as <em>switch rule expressions</em>.
In a <code>switch</code> expression, any expression may be used as a
switch rule expression, but in a <code>switch</code> statement, only a
statement expression may be used (<a
href="#jls-14.11.1">14.11.1</a>).</p>
</blockquote>
<p>The <em>result expressions</em> of a <code>switch</code> expression
are determined as follows:</p>
<ul>
<li><p>If the switch block consists of switch rules, then each switch
rule is considered in turn:</p>
<ul>
<li><p>If the switch rule is of the form <code>...</code>
<code>-&gt;</code> <em>Expression</em> then <em>Expression</em> is a
result expression of the <code>switch</code> expression.</p></li>
<li><p>If the switch rule is of the form <code>...</code>
<code>-&gt;</code> <em>Block</em> then every expression which is
immediately contained in a <code>yield</code> statement in
<em>Block</em> whose yield target is the given <code>switch</code>
expression, is a result expression of the <code>switch</code>
expression.</p></li>
</ul></li>
<li><p>If the switch block consists of switch labeled statement groups,
then every expression immediately contained in a <code>yield</code>
statement in the switch block whose yield target is the given
<code>switch</code> expression, is a result expression of the
<code>switch</code> expression.</p></li>
</ul>
<p>It is a compile-time error if a <code>switch</code> expression has no
result expressions.</p>
<p>A <code>switch</code> expression is a poly expression if it appears
in an assignment context or an invocation context (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-5.html#jls-5.2">5.2</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-5.html#jls-5.3">5.3</a>).
Otherwise, it is a standalone expression.</p>
<p>Where a poly <code>switch</code> expression appears in a context of a
particular kind with target type <em>T</em>, its result expressions
similarly appear in a context of the same kind with target type
<em>T</em>.</p>
<p>A poly <code>switch</code> expression is compatible with a target
type <em>T</em> if each of its result expressions is compatible with
<em>T</em>.</p>
<p>The type of a poly <code>switch</code> expression is the same as its
target type.</p>
<p>The type of a standalone <code>switch</code> expression is determined
as follows:</p>
<ul>
<li><p>If the result expressions all have the same type (which may be
the null type (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-4.html#jls-4.1">4.1</a>)),
then that is the type of the <code>switch</code> expression.</p></li>
<li><p>Otherwise, if the type of each result expression is
<code>boolean</code> or <code>Boolean</code>, then an unboxing
conversion (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-5.html#jls-5.1.8">5.1.8</a>)
is applied to each result expression of type <code>Boolean</code>, and
the <code>switch</code> expression has type
<code>boolean</code>.</p></li>
<li><p>Otherwise, if the type of each result expression is convertible
to a numeric type (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-5.html#jls-5.1.8">5.1.8</a>),
then the type of the <code>switch</code> expression is the result of
general numeric promotion (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-5.html#jls-5.6">5.6</a>)
applied to the result expressions.</p></li>
<li><p>Otherwise, boxing conversion (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-5.html#jls-5.1.7">5.1.7</a>)
is applied to each result expression that has a primitive type, after
which the type of the <code>switch</code> expression is the result of
applying capture conversion (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-5.html#jls-5.1.10">5.1.10</a>)
to the least upper bound (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-4.html#jls-4.10.4">4.10.4</a>)
of the types of the result expressions.</p></li>
</ul>
<h4 id="jls-15.28.2">15.28.2 Run-Time Evaluation of <code>switch</code>
Expressions</h4>
<p><strong>An executable</strong> <del>A</del> <code>switch</code>
expression <strong>(<a href="#jls-14.11.1.2">14.11.1.2</a>)</strong> is
evaluated by first evaluating the selector expression. <del>Then:</del>
If evaluation of the selector expression completes abruptly, then
<strong>evaluation of</strong> the <code>switch</code> expression
completes abruptly for the same reason.</p>
<div class="deleted">
<ul>
<li><p>Otherwise, if the result of evaluating the selector expression is
<code>null</code>, then a <code>NullPointerException</code> is thrown
and the entire <code>switch</code> expression completes abruptly for
that reason.</p></li>
<li><p>Otherwise, if the result of evaluating the selector expression is
of type <code>Character</code>, <code>Byte</code>, <code>Short</code>,
or <code>Integer</code>, it is subjected to unboxing conversion (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-5.html#jls-5.1.8">5.1.8</a>).
If this conversion completes abruptly, then the entire
<code>switch</code> expression completes abruptly for the same
reason.</p></li>
</ul>
</div>
<p>If evaluation of the selector expression completes normally <del>and
the result is non-<code>null</code>, and the subsequent unboxing
conversion (if any) completes normally,</del> then evaluation of the
<code>switch</code> expression continues by determining if a switch
label associated with the <strong>resolved</strong> switch block
<del>matches</del> <strong>applies to</strong> the value of the selector
expression (<a href="#jls-14.11.1.2">14.11.1.2</a>). Then:</p>
<ul>
<li><p><strong>If the process of determining which switch label applies
completes abruptly, then the entire <code>switch</code> expression
completes abruptly for the same reason.</strong></p></li>
<li><p>If no switch label <del>matches</del> <strong>applies</strong>,
<del>and the result of evaluating the selector expression is of an enum
type then an <code>IncompatibleClassChangeError</code> is thrown and the
entire <code>switch</code> expression completes abruptly for that
reason.</del> <strong>then one of the following holds:</strong></p>
<div class="inserted">
<ul>
<li><p>If the value of the selector expression is <code>null</code>,
then a <code>NullPointerException</code> is thrown and evaluation of the
<code>switch</code> expression completes abruptly for that
reason.</p></li>
<li><p>Otherwise, a <code>MatchException</code> is thrown and evaluation
of the <code>switch</code> expression completes abruptly for that
reason.</p></li>
</ul>
</div></li>
<li><p>If a switch label <del>matches</del> <strong>applies</strong>,
then one of the following <del>applies</del> <strong>holds</strong>:</p>
<ul>
<li><p>If it is the switch label for a switch rule expression, then the
expression is evaluated. If the result of evaluation is a value, then
the <code>switch</code> expression completes normally with the same
value.</p></li>
<li><p>If it is the switch label for a switch rule block, then the block
is executed. If this block completes normally, then the
<code>switch</code> expression completes normally.</p></li>
<li><p>If it is the switch label for a switch rule <code>throw</code>
statement, then the <code>throw</code> statement is executed.</p></li>
<li><p>Otherwise, all the statements in the switch block after the
<del>matching</del> switch label <strong>that applies</strong> are
executed in order. If these statements complete normally, then the
<code>switch</code> expression completes normally.</p></li>
</ul></li>
</ul>
<p>If execution of any statement or expression in the switch block
completes abruptly, it is handled as follows:</p>
<ul>
<li><p>If <del>execution</del> <strong>evaluation</strong> of an
expression completes abruptly, then <strong>evaluation of</strong> the
<code>switch</code> expression completes abruptly for the same
reason.</p></li>
<li><p>If execution of a statement completes abruptly because of a
<code>yield</code> with value <em>V</em>, then the <code>switch</code>
expression completes normally and the value of the <code>switch</code>
expression is <em>V</em>.</p></li>
<li><p>If execution of a statement completes abruptly for any reason
other than a <code>yield</code> with a value, then <strong>evaluation
of</strong> the <code>switch</code> expression completes abruptly for
the same reason.</p></li>
</ul>
<h2 id="jls-16">Chapter 16: Definite Assignment</h2>
<h3 id="jls-16.2">16.2 Definite Assignment and Statements</h3>
<h4 id="jls-16.2.9">16.2.9 <code>switch</code> Statements</h4>
<ul>
<li><p><em>V</em> is [un]assigned after a <code>switch</code> statement
(<a href="#jls-14.11">14.11</a>) iff all of the following are true:</p>
<ul>
<li><p><em>V</em> is [un]assigned before every <code>break</code>
statement (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-14.html#jls-14.15">14.15</a>)
that may exit the <code>switch</code> statement.</p></li>
<li><p>For each switch rule (<a href="#jls-14.11.1">14.11.1</a>) in the
switch block, <em>V</em> is [un]assigned after the switch rule
expression, switch rule block, or switch rule <code>throw</code>
statement introduced by the switch rule.</p></li>
<li><p>If there is a switch labeled statement group in the switch block,
then <em>V</em> is [un]assigned after the last block statement of the
last switch labeled statement group.</p></li>
<li><p>If <del>there is no <code>default</code> label in the switch
block</del> <strong>the switch statement is not exhaustive</strong>, or
if the switch block ends with a switch label followed by the
<code>}</code> separator, then <em>V</em> is [un]assigned after the
selector expression.</p></li>
</ul></li>
<li><p><em>V</em> is [un]assigned before the selector expression of a
<code>switch</code> statement iff <em>V</em> is [un]assigned before the
<code>switch</code> statement.</p></li>
<li><p><em>V</em> is [un]assigned before the switch rule expression,
switch rule block, or switch rule <code>throw</code> statement
introduced by a switch rule in the switch block iff <em>V</em> is
[un]assigned after the selector expression of the <code>switch</code>
statement.</p></li>
<li><p><em>V</em> is [un]assigned before the first block statement of a
switch labeled statement group in the switch block iff both of the
following are true:</p>
<ul>
<li><p><em>V</em> is [un]assigned after the selector expression of the
<code>switch</code> statement.</p></li>
<li><p>If the switch labeled statement group is not the first in the
switch block, <em>V</em> is [un]assigned after the last block statement
of the preceding switch labeled statement group.</p></li>
</ul></li>
<li><p><em>V</em> is [un]assigned before a block statement that is not
the first of a switch labeled statement group in the switch block iff
<em>V</em> is [un]assigned after the preceding block statement.</p></li>
</ul>
<h2 id="jls-18">Chapter 18: Type Inference</h2>
<h3 id="jls-18.5">18.5 Uses of Inference</h3>
<h4 id="jls-18.5.5"><strong>18.5.5 Record Pattern Type
Inference</strong></h4>
<div class="inserted">
<p>When a record pattern (<a href="#jls-14.30.1">14.30.1</a>) for a
generic record class <em>R</em> appears in a context in which values of
a type <em>T</em> will be matched against it, and the pattern does not
provide type arguments for <em>R</em>, the type arguments are inferred,
as described below.</p>
<ol type="1">
<li><p>If <em>T</em> is not downcast convertible (<a
href="#jls-5.5">5.5</a>) to the raw type <em>R</em>, inference
fails.</p></li>
<li><p>Otherwise, where <em>P<sub>1</sub></em>, ...,
<em>P<sub>n</sub></em> (<em>n</em> <em>≥</em> 1) are the type parameters
of <em>R</em>, let <em>α<sub>1</sub></em>, ..., <em>α<sub>n</sub></em>
be inference variables. An initial bound set, <em>B<sub>0</sub></em>, is
generated from the declared bounds of <em>P<sub>1</sub></em>, ...,
<em>P<sub>n</sub></em>, as described in <a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-18.html#jls-18.1.3">18.1.3</a>.</p></li>
<li><p>A type <em>T'</em> is derived from <em>T</em>, as follows:</p>
<ul>
<li><p>If <em>T</em> is a wildcard-parameterized type, let
<em>β<sub>1</sub></em>, ..., <em>β<sub>k</sub></em> (<em>k</em>
<em>≥</em> 1) be inference variables, where <em>k</em> is the number of
wildcard type arguments in <em>T</em>. <em>T'</em> is the result of
replacing each wildcard type argument in <em>T</em> with
<em>β<sub>i</sub></em> (1 ≤ <em>i</em> ≤ <em>k</em>).</p>
<p>Additional bounds for <em>β<sub>1</sub></em>, ...,
<em>β<sub>k</sub></em> are incorporated into <em>B<sub>0</sub></em> to
form a bound set <em>B<sub>1</sub></em>, as follows:</p>
<ul>
<li><p>If <em>β<sub>i</sub></em> (1 ≤ <em>i</em> ≤ <em>k</em>) replaced
a wildcard in <em>T</em> with upper bound <em>U</em>, then the bound
<em>β<sub>i</sub></em> <code>&lt;:</code> <em>U</em> appears in the
bound set</p></li>
<li><p>If <em>β<sub>i</sub></em> (1 ≤ <em>i</em> ≤ <em>k</em>) replaced
a wildcard in <em>T</em> with lower bound <em>L</em>, then the bound
<em>L</em> <code>&lt;:</code> <em>β<sub>i</sub></em> appears in the
bound set</p></li>
<li><p>Let <em>Q<sub>1</sub></em>, ..., <em>Q<sub>m</sub></em>
(<em>m</em> <em>≥</em> 1) be the type parameters of the class or
interface named by <em>T'</em>, and <em>A<sub>1</sub></em>, ...,
<em>A<sub>m</sub></em> be the type arguments of <em>T'</em>.</p>
<p>For each <em>β<sub>i</sub></em> (1 ≤ <em>i</em> ≤ <em>k</em>), and
for each type <em>U</em> delimited by <code>&amp;</code> in the
<em>TypeBound</em> of the type parameter corresponding to
<em>β<sub>i</sub></em> (1 ≤ <em>i</em> ≤ <em>m</em>), the bound
<em>β<sub>i</sub></em> <code>&lt;:</code>
<em>U</em><code>[</code><em>Q<sub>1</sub></em>:=<em>A<sub>1</sub></em>,
..., <em>Q<sub>m</sub></em>:=<em>A<sub>m</sub></em><code>]</code>
appears in the bound set. If there is no <em>TypeBound</em> for the type
parameter corresponding to <em>β<sub>i</sub></em>, or if no proper upper
bounds are derived from the <em>TypeBound</em> (only dependencies), then
the bound <em>β<sub>i</sub></em> <code>&lt;:</code> <code>Object</code>
appears in the set.</p></li>
</ul></li>
<li><p>If <em>T</em> is any other class or interface type, then
<em>T'</em> is the same as <em>T</em>, and <em>B<sub>1</sub></em> is the
same as <em>B<sub>0</sub></em>.</p></li>
<li><p>If <em>T</em> is a type variable or an intersection type, then
for each upper bound of the type variable or element of the intersection
type, this step and step 4 are repeated recursively. All bounds produced
in steps 3 and 4 are incorporated into a single bound set.</p></li>
</ul></li>
<li><p>If <em>T'</em> is a parameterization of a generic class
<em>G</em>, and there exists a supertype of
<em>R</em><code>&lt;</code><em>α<sub>1</sub></em>, ...,
<em>α<sub>n</sub></em><code>&gt;</code> that is also a parameterization
of <em>G</em>, let <em>R'</em> be that supertype. The constraint formula
‹<em>T'</em> = <em>R'</em>› is reduced (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-18.html#jls-18.2">18.2</a>)
and the resulting bounds are incorporated into <em>B<sub>1</sub></em> to
produce a new bound set, <em>B<sub>2</sub></em>.</p>
<p>Otherwise, <em>B<sub>2</sub></em> is the same as
<em>B<sub>1</sub></em>.</p>
<p>If <em>B<sub>2</sub></em> contains the bound <em>false</em>,
inference fails.</p></li>
<li><p>Otherwise, the inference variables <em>α<sub>1</sub></em>, ...,
<em>α<sub>n</sub></em> are resolved in <em>B<sub>2</sub></em> (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-18.html#jls-18.4">18.4</a>).
Unlike normal resolution, in this case resolution skips the step that
attempts to produce an instantiation for an inference variable from its
proper lower bounds or proper upper bounds; instead, any new
instantiations are created by skipping directly to the step that
introduces fresh type variables.</p>
<p>If resolution fails, then inference fails.</p></li>
<li><p>Otherwise, let <em>A<sub>1</sub></em>, ...,
<em>A<sub>n</sub></em> be the resolved instantiations for
<em>α<sub>1</sub></em>, ..., <em>α<sub>n</sub></em>, and let
<em>Y<sub>1</sub></em>, ..., <em>Y<sub>p</sub></em> (<em>p</em> ≥ 0) be
any fresh type variables introduced by resolution.</p>
<p>The type of the record pattern is the upward projection of
<em>R</em><code>&lt;</code><em>A<sub>1</sub></em>, ...,
<em>A<sub>n</sub></em><code>&gt;</code> with respect to
<em>Y<sub>1</sub></em>, ..., <em>Y<sub>p</sub></em> (<a
href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-4.html#jls-4.10.5">4.10.5</a>).</p></li>
</ol>
<div class="example">
<p>Example 18.5.5-1. Record Pattern Type Inference</p>
<p>The following program infers a parameterization for a record
class:</p>
<pre><code>record Mapper&lt;T&gt;(T in, T out) implements UnaryOperator&lt;T&gt; {
    public T apply(T arg) { return in.equals(arg) ? out : null; }
}

void test(UnaryOperator&lt;? extends CharSequence&gt; op) {
    if (op instanceof Mapper(var in, var out)) {
        boolean shorter = out.length() &lt; in.length();
    }
}</code></pre>
<!-- javac bug: we'd prefer to make the type Function<? super String, ? extends CharSequence>,
     but javac's castability check can't handle that -->
<p>In this case, <em>R</em> is the record class <code>Mapper</code>, and
<em>T</em> is the type
<code>UnaryOperator&lt;? extends CharSequence&gt;</code>. <em>T</em> is
downcast convertible to raw <code>Mapper</code>, so we'll infer an
instantiation for <em>α</em> in
<code>Mapper&lt;</code><em>α</em><code>&gt;</code>.
<!--*T'* is the type `Function<`*β~1~*`,` *β~2~*`>`, where *β~1~* has lower bound
`String` and *β~2~* has upper bound `CharSequence`.--> <em>T'</em> is
the type <code>UnaryOperator&lt;</code><em>β</em><code>&gt;</code>,
where <em>β</em> has upper bound <code>CharSequence</code>.</p>
<!--`Mapper<`*α*`>` has the supertype `Function<`*α*`,` *α*`>`, so we'll reduce the
constraint formula ‹`Function<`*β~1~*`,` *β~2~*`>` = `Function<`*α*`,` *α*`>`›.
This leads to bounds *α* = *β~1~* and *α* = *β~2~*.
Incorporation further infers that *α* `<:` `CharSequence` and `String` `<:` *α*.-->
<p><code>Mapper&lt;</code><em>α</em><code>&gt;</code> has the supertype
<code>UnaryOperator&lt;</code><em>α</em><code>&gt;</code>, so we'll
reduce the constraint formula
‹<code>UnaryOperator&lt;</code><em>β</em><code>&gt;</code> =
<code>UnaryOperator&lt;</code><em>α</em><code>&gt;</code>›. This leads
to the bound <em>α</em> = <em>β</em>. Incorporation further infers that
<em>α</em> <code>&lt;:</code> <code>CharSequence</code>.</p>
<p>Now we resolve <em>α</em>, yielding <em>α</em> = <code>Y</code>, a
fresh type variable with upper bound <code>CharSequence</code>.
<!--and lower bound `String`.--> Finally, we find the upward projection
of <code>Mapper&lt;Y&gt;</code> with respect to <code>Y</code>,
inferring that the type of the record pattern is
<code>Mapper&lt;? extends CharSequence&gt;</code>.</p>
<p>Once we know the type of the record pattern, we can find its
component types, which are matched against the nested patterns. Pattern
variables <code>in</code> and <code>out</code> both have type
<code>CharSequence</code>.</p>
</div>
</div>
</main><footer class="legal-footer"><hr/><a href="../legal/copyright.html">Copyright</a> &copy; 1993, 2023, Oracle and/or its affiliates, 500 Oracle Parkway, Redwood Shores, CA 94065 USA.<br>All rights reserved. Use is subject to <a href="https://www.oracle.com/java/javase/terms/license/java20speclicense.html">license terms</a> and the <a href="https://www.oracle.com/technetwork/java/redist-137594.html">documentation redistribution policy</a>. <!-- Version 20+36-2344 --></footer>
</body>
</html>