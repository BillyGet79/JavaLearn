# 计算机网络面试

## 一、网络分层

### 1.OSI与TCP/IP各层的结构与功能

OSI七层模型：

![OSI 七层模型](photo/osi-7-model.png)

TCP/IP四层模型：

1. 应用层
2. 传输层
3. 网络层
4. 网络接口层

![TCP/IP 四层模型](https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-ip-4-model.png)

### 2.为什么网络要分层？

1. **各层之间相互独立**：各层之间相互独立，各层之间不需要关心其他层是如何实现的，只需要知道自己如何调用下层提供好的功能就可以了（可以简单理解为接口调用）**。这个和我们对开发时系统进行分层是一个道理。**
2. **提高了灵活性和可替换性**：每一层都可以使用最适合的技术来实现，你只需要保证你提供的功能以及暴露的接口的规则没有改变就行了。并且，每一层都可以根据需要进行修改或替换，而不会影响到整个网络的结构。**这个和我们平时开发系统的时候要求的高内聚、低耦合的原则也是可以对应上的**。
3. **大问题化小**：分层可以将复杂的网络问题分解为许多比较小的、界线比较清晰简单的小问题来处理和解决。这样使得复杂的计算机网络系统变得易于设计，实现和标准化。 **这个和我们平时开发的时候，一般会将系统功能分解，然后将复杂的问题分解为容易理解的更小的问题是相对应的，这些较小的问题具有更好的边界（目标和接口）定义。**

### 3.OSI与TCP/IP各层都有哪些协议？

这里只讲TCP/IP的

- 应用层常见协议：HTTP、SMTP、POP3/IMAP、FTP、Telnet、SSH、RTP、DNS
- 传输层常见协议：TCP、UDP
- 网络层常见协议：IP、ARP、ICMP、NAT、OSPF、RIP、OSPF、RIP、BGP
- 网络接口层：CSMA/CD、MAC、差错检测、多路访问、以太网

## 二、TCP与UDP（重要）

### 1.TCP的三次握手与四次挥手的内容？TCP为什么连接是三次握手而断开是四次挥手？

#### （1）内容

建立一个 TCP 连接需要“三次握手”，缺一不可：

- **一次握手**:客户端发送带有 SYN（SEQ=x） 标志的数据包 -> 服务端，然后客户端进入 **SYN_SEND** 状态，等待服务端的确认；
- **二次握手**:服务端发送带有 SYN+ACK(SEQ=y,ACK=x+1) 标志的数据包 –> 客户端,然后服务端进入 **SYN_RECV** 状态；
- **三次握手**:客户端发送带有 ACK(ACK=y+1) 标志的数据包 –> 服务端，然后客户端和服务端都进入**ESTABLISHED** 状态，完成 TCP 三次握手。

断开一个 TCP 连接则需要“四次挥手”，缺一不可：

- **第一次挥手**：客户端发送一个 FIN（SEQ=x） 标志的数据包->服务端，用来关闭客户端到服务端的数据传送。然后客户端进入 **FIN-WAIT-1** 状态。
- **第二次挥手**：服务端收到这个 FIN（SEQ=X） 标志的数据包，它发送一个 ACK （ACK=x+1）标志的数据包->客户端 。然后服务端进入 **CLOSE-WAIT** 状态，客户端进入 **FIN-WAIT-2** 状态。
- **第三次挥手**：服务端发送一个 FIN (SEQ=y)标志的数据包->客户端，请求关闭连接，然后服务端进入 **LAST-ACK** 状态。
- **第四次挥手**：客户端发送 ACK (ACK=y+1)标志的数据包->服务端，然后客户端进入**TIME-WAIT**状态，服务端在收到 ACK (ACK=y+1)标志的数据包后进入 CLOSE 状态。此时如果客户端等待 **2MSL** 后依然没有收到回复，就证明服务端已正常关闭，随后客户端也可以关闭连接了。

#### （2）为什么连接是三次握手？

三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。

1. **第一次握手**：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常
2. **第二次握手**：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常
3. **第三次握手**：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常

三次握手就能确认双方收发功能都正常，缺一不可。

至于为什么不能是两次或者四次，可以看这个知乎专栏：https://www.zhihu.com/question/24853633/answer/115173386

#### （3）为什么断开是四次挥手？

TCP 是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。

举个例子：A 和 B 打电话，通话即将结束后。

1. **第一次挥手**：A 说“我没啥要说的了”
2. **第二次挥手**：B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话
3. **第三次挥手**：于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”
4. **第四次挥手**：A 回答“知道了”，这样通话才算结束。



1. 为什么不能把服务端发送的 ACK 和 FIN 合并起来，变成三次挥手？

   因为服务端收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务端到客户端的数据传送。

2. 为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？

   第四次挥手时，客户端发送给服务端的 ACK 有可能丢失，如果服务端因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN，如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。

   > **MSL(Maximum Segment Lifetime)** : 一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接。

### 2.TCP 与 UDP 的区别及使⽤场景？

|                        | TCP            | UDP        |
| ---------------------- | -------------- | ---------- |
| 是否面向连接           | 是             | 否         |
| 是否可靠               | 是             | 否         |
| 是否有状态             | 是             | 否         |
| 传输效率               | 较慢           | 较快       |
| 传输形式               | 字节流         | 数据报文段 |
| 首部开销               | 20 ～ 60 bytes | 8 bytes    |
| 是否提供广播或多播服务 | 否             | 是         |

**UDP 一般用于即时通信**，比如：语音、 视频、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别也不大。

**TCP 用于对传输准确性要求特别高的场景**，比如文件传输、发送和接收邮件、远程登录等等。

### 3.为什么 DNS 协议使⽤ UDP？只使⽤了 UDP 吗？

(GPT解答)

DNS（域名系统）协议通常使用UDP（用户数据报协议）进行通信，而不是TCP（传输控制协议）。这是因为DNS查询通常是短暂且轻量级的，使用UDP可以提供更高的性能和效率。

以下是一些理由：

1. **低延迟：** UDP是无连接的，不需要建立连接和维护状态，因此可以减少通信的延迟。对于DNS查询来说，快速响应是至关重要的。
2. **资源消耗较少：** UDP相比于TCP具有更小的开销，因为它不需要维护连接状态、进行流量控制和拥塞控制等。这使得UDP更适合处理大量的短暂查询请求，而不会占用过多的资源。
3. **简单性：** UDP协议相对于TCP更加简单，实现和部署起来更加容易。这使得DNS服务器和客户端能够更快地响应和处理查询请求。

虽然DNS通常使用UDP进行查询，但是在一些情况下，例如对于较大的DNS响应或者对于需要可靠传输的特殊情况（例如域名解析过程中的区域传输），也可以使用TCP。因此，DNS协议不仅限于UDP，而是可以根据需要选择合适的传输协议。

### 4.TCP 是如何保证传输的可靠性？（⾥⾯涉及到的知识点⾮常多，每个都能挖掘不少问题，例如重传机制、流量控制、拥塞控制。如果⽬标是⼤⼚的话，⼀定要吃透，⾯试经常会问的）

https://javaguide.cn/cs-basics/network/tcp-reliability-guarantee.html

### 5.使⽤ TCP 的协议有哪些?使⽤ UDP 的协议有哪些?HTTP 基于 TCP 还是 UDP？

#### （1）运行于TCP之上的协议

HTTP（2.0之前）、HTTPS、FPT、SMTP、POP3/IMAP、Telnet、SSH

#### （2）运行于UDP之上的协议

HTTP（3.0）、DHCP、DNS

#### (3)HTTP基于TCP还是UDP？

HTTP/3.0 之前是基于 TCP 协议的，而 HTTP/3.0 将弃用 TCP，改用 **基于 UDP 的 QUIC 协议** 。

此变化解决了 HTTP/2 中存在的队头阻塞问题。队头阻塞是指在 HTTP/2.0 中，多个 HTTP 请求和响应共享一个 TCP 连接，如果其中一个请求或响应因为网络拥塞或丢包而被阻塞，那么后续的请求或响应也无法发送，导致整个连接的效率降低。这是由于 HTTP/2.0 在单个 TCP 连接上使用了多路复用，受到 TCP 拥塞控制的影响，少量的丢包就可能导致整个 TCP 连接上的所有流被阻塞。HTTP/3.0 在一定程度上解决了队头阻塞问题，一个连接建立多个不同的数据流，这些数据流之间独立互不影响，某个数据流发生丢包了，其数据流不受影响（本质上是多路复用+轮询）。

除了解决队头阻塞问题，HTTP/3.0 还可以减少握手过程的延迟。在 HTTP/2.0 中，如果要建立一个安全的 HTTPS 连接，需要经过 TCP 三次握手和 TLS 握手：

1. TCP 三次握手：客户端和服务器交换 SYN 和 ACK 包，建立一个 TCP 连接。这个过程需要 1.5 个 RTT（round-trip time），即一个数据包从发送到接收的时间。
2. TLS 握手：客户端和服务器交换密钥和证书，建立一个 TLS 加密层。这个过程需要至少 1 个 RTT（TLS 1.3）或者 2 个 RTT（TLS 1.2）。

所以，HTTP/2.0 的连接建立就至少需要 2.5 个 RTT（TLS 1.3）或者 3.5 个 RTT（TLS 1.2）。而在 HTTP/3.0 中，使用的 QUIC 协议（TLS 1.3，TLS 1.3 除了支持 1 个 RTT 的握手，还支持 0 个 RTT 的握手）连接建立仅需 0-RTT 或者 1-RTT。这意味着 QUIC 在最佳情况下不需要任何的额外往返时间就可以建立新连接。

## 三、HTTP（重要）

### 1.HTTP状态码有哪些？

![常见 HTTP 状态码](photo/http-status-code.png)

### 2.一次完整的HTTP请求所经的步骤

https://javaguide.cn/cs-basics/network/the-whole-process-of-accessing-web-pages.html

### 3.HTTP协议了解么？HTTP是基于TCP还是UDP的？

TCP这里讲过了，就不讲了

### 4.HTTP报文的内容简单说一下！HTTP请求报文和响应报文中有哪些数据？

HTTP请求报文：

1. **请求行（Request Line）：** 包含请求方法、请求的资源路径和HTTP协议版本。
2. **请求头部（Request Headers）：** 包含了客户端向服务器传递的各种信息，例如用户代理、内容类型、Cookie等。
3. **请求体（Request Body）：** 在一些请求中，比如POST请求，会带有请求体，用于传递实际的数据。

HTTP响应报文：

1. **状态行（Status Line）：** 包含HTTP协议版本、状态码和状态消息。
2. **响应头部（Response Headers）：** 包含了服务器传递给客户端的各种信息，例如服务器类型、内容长度、响应时间等。
3. **响应体（Response Body）：** 实际的响应内容，可以是HTML、JSON、图片等各种格式的数据。

### 5.HTTP和HTTPS的区别了解么？

https://javaguide.cn/cs-basics/network/http-vs-https.html

